Entendido, meu amigo. Voc√™ n√£o quer apenas *usar* uma ferramenta, voc√™ quer *construir* a sua pr√≥pria plataforma, um "ManyChat-like" focado em WhatsApp N√£o-Oficial, com liberdade total para simular intera√ß√µes humanas.

Este √© um projeto de software robusto e empolgante. A grande vantagem √© o controle total. O grande desafio √© a instabilidade da "API" (o *conector*) que voc√™ ter√° que gerenciar.

Para desenhar o roadmap, precisamos quebrar a aplica√ß√£o em seus componentes principais (arquitetura) e depois detalhar as telas e funcionalidades de cada um.

---

### 1. üèõÔ∏è Arquitetura de Alto N√≠vel do Projeto

Sua aplica√ß√£o n√£o ser√° uma coisa s√≥ (monolito). Ela ser√° composta por, no m√≠nimo, 3 partes:

1.  **Frontend (O "Painel"):** A aplica√ß√£o web (em React, Vue, etc.) onde *voc√™* (ou seus usu√°rios) ir√° configurar tudo. √â aqui que moram as "telas".
2.  **Backend (A "Intelig√™ncia"):** Uma API (em Node.js, Python, etc.) que gerencia usu√°rios, salva os funis, armazena o hist√≥rico de chat e decide o que fazer.
3.  **Servi√ßo de Conex√£o (O "Conector"):** Um ou mais servi√ßos separados (provavelmente em Node.js usando **Baileys**) que mant√™m a conex√£o *real* com o WhatsApp Web. √â a parte inst√°vel.

**Por que separar o "Conector"?** Porque ele vai travar e cair. Voc√™ precisa poder reinici√°-lo, ou at√© mesmo ter *v√°rios* (um para cada n√∫mero de WhatsApp conectado), sem derrubar seu Backend ou Frontend.

---

### 2. üíª Telas e Funcionalidades Detalhadas (O Roadmap de Features)

Aqui est√° o detalhamento das "telas" (m√≥dulos) que voc√™ precisar√° construir no seu **Frontend** e as funcionalidades de **Backend** correspondentes.

#### M√≥dulo 1: Gerenciamento de Conex√µes (O Onboarding)

√â a primeira coisa que seu usu√°rio v√™.

* **Tela: "Inst√¢ncias" ou "Conex√µes"**
    * **Visual:** Uma lista (cards ou tabela) de todas as contas de WhatsApp conectadas.
    * **Funcionalidades:**
        * Bot√£o "Adicionar nova conex√£o".
        * Status da conex√£o (ex: `Conectado`, `Aguardando leitura do QR`, `Desconectado`).
        * Bot√£o "Reconectar" (que gera um novo QR Code).
        * Bot√£o "Desconectar" (faz o logout).

* **Tela: "Conectar Novo WhatsApp" (Modal ou P√°gina)**
    * **Visual:** Um QR Code grande.
    * **Funcionalidade (Backend/Conector):**
        1.  O Frontend pede ao Backend: "quero um novo QR Code".
        2.  O Backend inicia uma nova inst√¢ncia do seu `Servi√ßo de Conex√£o` (Baileys).
        3.  O Baileys gera um QR Code.
        4.  O Backend envia esse QR Code para o Frontend exibir.
        5.  O Frontend fica "ouvindo" (via WebSocket ou polling) o status: "QR Lido", "Conectado com Sucesso".

#### M√≥dulo 2: Contatos (Mini-CRM)

Onde voc√™ gerencia as pessoas que falaram com o bot.

* **Tela: "Lista de Contatos"**
    * **Visual:** Uma tabela com: `Nome`, `N√∫mero`, `Tags` (ex: "Lead Frio", "Agendado"), `Respons√°vel` (se tiver m√∫ltiplos usu√°rios).
    * **Funcionalidades:**
        * Pesquisar contatos.
        * Filtrar por tags.
        * Adicionar/Remover tags em massa.
        * Importar/Exportar contatos.

* **Tela: "Detalhe do Contato"**
    * **Visual:** Dividida em duas colunas.
    * **Coluna 1 (Dados):**
        * Campos do contato: `Nome`, `Email`, `Empresa`, etc. (Campos personalizados s√£o importantes).
        * Lista de `Tags` do contato.
        * Notas internas.
    * **Coluna 2 (Hist√≥rico):**
        * O hist√≥rico completo da conversa (mensagens do bot e do usu√°rio).

#### M√≥dulo 3: Caixa de Entrada (Atendimento Humano)

Para "simular intera√ß√£o humana", voc√™ precisa da habilidade de um humano assumir a conversa.

* **Tela: "Caixa de Entrada" (Inbox)**
    * **Visual:** Similar ao WhatsApp Web ou Telegram.
    * **Coluna 1 (Lista de Chats):** Lista de conversas ativas, com a √∫ltima mensagem.
    * **Coluna 2 (Chat Ativo):** A conversa selecionada.
    * **Coluna 3 (Dados do Contato):** Os mesmos dados do M√≥dulo 2 ("Detalhe do Contato").
    * **Funcionalidades Chave:**
        * Um campo de texto para o humano **enviar uma mensagem manualmente**.
        * Bot√£o "Pausar Bot" (para este usu√°rio espec√≠fico, para que o funil n√£o atrapalhe o humano).
        * Bot√£o "Reativar Bot" (devolve o controle ao funil).
        * Enviar m√≠dias (imagens, √°udio, documentos).

#### M√≥dulo 4: Editor de Funil (O "Pipeline Faseado")

Este √© o cora√ß√£o do seu projeto. O seu "ManyChat" ou "n8n".

* **Tela: "Lista de Funis"**
    * **Visual:** Cards de cada funil (ex: "Funil de Boas-Vindas", "Funil de Agendamento").
    * **Funcionalidades:**
        * "Criar novo funil".
        * Ativar/Desativar um funil.
        * Estat√≠sticas (quantas pessoas entraram, quantas converteram).

* **Tela: "Editor de Funil" (O Canvas Visual)**
    * **Visual:** Um canvas de "arrastar e soltar" (como Typebot, n8n, ou o editor de fluxo do ManyChat).
    * **Funcionalidades (Os "N√≥s" do pipeline):**
        * **Gatilho (Trigger):** O que inicia o funil? (Ex: "Primeira mensagem", "Mensagem cont√©m 'vendas'", "Tag 'Lead' foi adicionada").
        * **A√ß√£o: Enviar Mensagem:** Enviar texto, imagem, v√≠deo, √°udio. (Importante: simular digita√ß√£o, "typing...").
        * **A√ß√£o: Enviar Bot√µes:** Enviar bot√µes de resposta r√°pida.
        * **L√≥gica: Aguardar Resposta:** Espera a pr√≥xima mensagem do usu√°rio.
        * **L√≥gica: Condi√ß√£o (IF/THEN):** O que fazer baseado na resposta? (Ex: `Se resposta cont√©m "sim"`, `Se resposta cont√©m "n√£o"`).
        * **L√≥gica: Atraso (Delay):** Esperar X minutos/horas (para parecer humano).
        * **A√ß√£o: Adicionar/Remover Tag:** (Ex: Mover de "Lead Frio" para "Lead Quente").
        * **A√ß√£o: Notificar Humano:** Envia uma mensagem (no pr√≥prio app ou email) para um vendedor.
        * **A√ß√£o: Transferir para Funil:** Inicia outro funil.
        * **A√ß√£o: Webhook:** Envia os dados para uma API externa (ex: seu CRM, Google Calendar).

#### M√≥dulo 5: O Funil Inteligente (A "Simula√ß√£o Humana" com IA)

Para *realmente* simular um humano e agendar a reuni√£o, seu funil n√£o pode ser s√≥ `IF/THEN`. Ele precisa de IA. Aqui entra o **WorkersAI** (ou OpenAI, Gemini, etc.).

* **Novo "N√≥" no Editor de Funil:**
    * **L√≥gica: "Perguntar √† IA" (AI-Powered Response)**
        * **Como funciona:** Em vez de uma condi√ß√£o `IF/THEN`, voc√™ usa este n√≥.
        1.  Ele pega a mensagem do usu√°rio.
        2.  Envia para o WorkersAI (ou outra API) junto com um **Prompt** que voc√™ define.
        3.  **Exemplo de Prompt:** "Voc√™ √© um assistente de vendas. Seu √∫nico objetivo √© agendar uma reuni√£o. O usu√°rio disse: `[Mensagem do Usu√°rio]`. O hist√≥rico da conversa √©: `[Hist√≥rico]`. O usu√°rio est√° na fase `[Tag]`. Responda de forma natural, fa√ßa a pr√≥xima pergunta necess√°ria para conseguir o Nome, Email e melhor Hor√°rio. Se j√° tiver tudo, proponha um hor√°rio."
        4.  O n√≥ recebe a resposta da IA.
        5.  O n√≥ "Enviar Mensagem" envia essa resposta da IA para o usu√°rio.

* **Tela: "Configura√ß√µes de IA"**
    * **Visual:** Campos de formul√°rio.
    * **Funcionalidades:**
        * Campo para a chave de API (OpenAI, Cloudflare, etc.).
        * Um campo de texto grande para o "Prompt Mestre" (a personalidade base do seu bot).

---

### 3. üó∫Ô∏è Roadmap de Desenvolvimento (MVP)

Voc√™ n√£o vai construir tudo isso de uma vez. Eu sugiro esta ordem:

1.  **MVP 1 (Prova de Conceito):**
    * Backend + Servi√ßo de Conex√£o (Baileys) rodando local.
    * Tela de "Conex√µes" (s√≥ para gerar o QR Code e ver o status).
    * Tela de "Caixa de Entrada" (simples, s√≥ para *responder manualmente*).
    * **Objetivo:** Provar que voc√™ consegue conectar e conversar manualmente.

2.  **MVP 2 (O Bot Est√°tico):**
    * M√≥dulo "Editor de Funil" (com n√≥s simples: Enviar Texto, Aguardar Resposta, Condi√ß√£o IF/THEN).
    * Um "Motor de Funil" no Backend que interpreta o JSON do editor e executa o funil.
    * M√≥dulo "Contatos" (s√≥ para ver quem est√° em qual funil).
    * **Objetivo:** Ter um chatbot de regras funcionando.

3.  **Vers√£o 1.0 (O Bot Inteligente):**
    * Adicionar o M√≥dulo "Caixa de Entrada" completo (com pausa/play do bot).
    * Adicionar o "N√≥ de IA" (WorkersAI) no Editor de Funil.
    * Adicionar o "N√≥ de Webhook" (para integrar com Calendly/Google Calendar e *de fato* agendar a reuni√£o).
    * **Objetivo:** Atingir seu objetivo final de agendamento de reuni√£o "humano".

Este √© um projeto de m√©dio a grande porte, mas incrivelmente poderoso se bem executado. O maior desafio t√©cnico ser√° manter o `Servi√ßo de Conex√£o` (Baileys) est√°vel e atualizado.

Posso ajudar a detalhar a arquitetura de comunica√ß√£o entre o **Backend** e o **Servi√ßo de Conex√£o (Baileys)**? (Dica: Webhooks e RabbitMQ/Redis seriam seus melhores amigos aqui).

Entendido, meu amigo. Voc√™ n√£o quer apenas *usar* uma ferramenta, voc√™ quer *construir* a sua pr√≥pria plataforma, um "ManyChat-like" focado em WhatsApp N√£o-Oficial, com liberdade total para simular intera√ß√µes humanas.

Este √© um projeto de software robusto e empolgante. A grande vantagem √© o controle total. O grande desafio √© a instabilidade da "API" (o *conector*) que voc√™ ter√° que gerenciar.

Para desenhar o roadmap, precisamos quebrar a aplica√ß√£o em seus componentes principais (arquitetura) e depois detalhar as telas e funcionalidades de cada um.

---

### 1. üèõÔ∏è Arquitetura de Alto N√≠vel do Projeto

Sua aplica√ß√£o n√£o ser√° uma coisa s√≥ (monolito). Ela ser√° composta por, no m√≠nimo, 3 partes:

1.  **Frontend (O "Painel"):** A aplica√ß√£o web (em React, Vue, etc.) onde *voc√™* (ou seus usu√°rios) ir√° configurar tudo. √â aqui que moram as "telas".
2.  **Backend (A "Intelig√™ncia"):** Uma API (em Node.js, Python, etc.) que gerencia usu√°rios, salva os funis, armazena o hist√≥rico de chat e decide o que fazer.
3.  **Servi√ßo de Conex√£o (O "Conector"):** Um ou mais servi√ßos separados (provavelmente em Node.js usando **Baileys**) que mant√™m a conex√£o *real* com o WhatsApp Web. √â a parte inst√°vel.

**Por que separar o "Conector"?** Porque ele vai travar e cair. Voc√™ precisa poder reinici√°-lo, ou at√© mesmo ter *v√°rios* (um para cada n√∫mero de WhatsApp conectado), sem derrubar seu Backend ou Frontend.

---

### 2. üíª Telas e Funcionalidades Detalhadas (O Roadmap de Features)

Aqui est√° o detalhamento das "telas" (m√≥dulos) que voc√™ precisar√° construir no seu **Frontend** e as funcionalidades de **Backend** correspondentes.

#### M√≥dulo 1: Gerenciamento de Conex√µes (O Onboarding)

√â a primeira coisa que seu usu√°rio v√™.

* **Tela: "Inst√¢ncias" ou "Conex√µes"**
    * **Visual:** Uma lista (cards ou tabela) de todas as contas de WhatsApp conectadas.
    * **Funcionalidades:**
        * Bot√£o "Adicionar nova conex√£o".
        * Status da conex√£o (ex: `Conectado`, `Aguardando leitura do QR`, `Desconectado`).
        * Bot√£o "Reconectar" (que gera um novo QR Code).
        * Bot√£o "Desconectar" (faz o logout).

* **Tela: "Conectar Novo WhatsApp" (Modal ou P√°gina)**
    * **Visual:** Um QR Code grande.
    * **Funcionalidade (Backend/Conector):**
        1.  O Frontend pede ao Backend: "quero um novo QR Code".
        2.  O Backend inicia uma nova inst√¢ncia do seu `Servi√ßo de Conex√£o` (Baileys).
        3.  O Baileys gera um QR Code.
        4.  O Backend envia esse QR Code para o Frontend exibir.
        5.  O Frontend fica "ouvindo" (via WebSocket ou polling) o status: "QR Lido", "Conectado com Sucesso".

#### M√≥dulo 2: Contatos (Mini-CRM)

Onde voc√™ gerencia as pessoas que falaram com o bot.

* **Tela: "Lista de Contatos"**
    * **Visual:** Uma tabela com: `Nome`, `N√∫mero`, `Tags` (ex: "Lead Frio", "Agendado"), `Respons√°vel` (se tiver m√∫ltiplos usu√°rios).
    * **Funcionalidades:**
        * Pesquisar contatos.
        * Filtrar por tags.
        * Adicionar/Remover tags em massa.
        * Importar/Exportar contatos.

* **Tela: "Detalhe do Contato"**
    * **Visual:** Dividida em duas colunas.
    * **Coluna 1 (Dados):**
        * Campos do contato: `Nome`, `Email`, `Empresa`, etc. (Campos personalizados s√£o importantes).
        * Lista de `Tags` do contato.
        * Notas internas.
    * **Coluna 2 (Hist√≥rico):**
        * O hist√≥rico completo da conversa (mensagens do bot e do usu√°rio).

#### M√≥dulo 3: Caixa de Entrada (Atendimento Humano)

Para "simular intera√ß√£o humana", voc√™ precisa da habilidade de um humano assumir a conversa.

* **Tela: "Caixa de Entrada" (Inbox)**
    * **Visual:** Similar ao WhatsApp Web ou Telegram.
    * **Coluna 1 (Lista de Chats):** Lista de conversas ativas, com a √∫ltima mensagem.
    * **Coluna 2 (Chat Ativo):** A conversa selecionada.
    * **Coluna 3 (Dados do Contato):** Os mesmos dados do M√≥dulo 2 ("Detalhe do Contato").
    * **Funcionalidades Chave:**
        * Um campo de texto para o humano **enviar uma mensagem manualmente**.
        * Bot√£o "Pausar Bot" (para este usu√°rio espec√≠fico, para que o funil n√£o atrapalhe o humano).
        * Bot√£o "Reativar Bot" (devolve o controle ao funil).
        * Enviar m√≠dias (imagens, √°udio, documentos).

#### M√≥dulo 4: Editor de Funil (O "Pipeline Faseado")

Este √© o cora√ß√£o do seu projeto. O seu "ManyChat" ou "n8n".

* **Tela: "Lista de Funis"**
    * **Visual:** Cards de cada funil (ex: "Funil de Boas-Vindas", "Funil de Agendamento").
    * **Funcionalidades:**
        * "Criar novo funil".
        * Ativar/Desativar um funil.
        * Estat√≠sticas (quantas pessoas entraram, quantas converteram).

* **Tela: "Editor de Funil" (O Canvas Visual)**
    * **Visual:** Um canvas de "arrastar e soltar" (como Typebot, n8n, ou o editor de fluxo do ManyChat).
    * **Funcionalidades (Os "N√≥s" do pipeline):**
        * **Gatilho (Trigger):** O que inicia o funil? (Ex: "Primeira mensagem", "Mensagem cont√©m 'vendas'", "Tag 'Lead' foi adicionada").
        * **A√ß√£o: Enviar Mensagem:** Enviar texto, imagem, v√≠deo, √°udio. (Importante: simular digita√ß√£o, "typing...").
        * **A√ß√£o: Enviar Bot√µes:** Enviar bot√µes de resposta r√°pida.
        * **L√≥gica: Aguardar Resposta:** Espera a pr√≥xima mensagem do usu√°rio.
        * **L√≥gica: Condi√ß√£o (IF/THEN):** O que fazer baseado na resposta? (Ex: `Se resposta cont√©m "sim"`, `Se resposta cont√©m "n√£o"`).
        * **L√≥gica: Atraso (Delay):** Esperar X minutos/horas (para parecer humano).
        * **A√ß√£o: Adicionar/Remover Tag:** (Ex: Mover de "Lead Frio" para "Lead Quente").
        * **A√ß√£o: Notificar Humano:** Envia uma mensagem (no pr√≥prio app ou email) para um vendedor.
        * **A√ß√£o: Transferir para Funil:** Inicia outro funil.
        * **A√ß√£o: Webhook:** Envia os dados para uma API externa (ex: seu CRM, Google Calendar).

#### M√≥dulo 5: O Funil Inteligente (A "Simula√ß√£o Humana" com IA)

Para *realmente* simular um humano e agendar a reuni√£o, seu funil n√£o pode ser s√≥ `IF/THEN`. Ele precisa de IA. Aqui entra o **WorkersAI** (ou OpenAI, Gemini, etc.).

* **Novo "N√≥" no Editor de Funil:**
    * **L√≥gica: "Perguntar √† IA" (AI-Powered Response)**
        * **Como funciona:** Em vez de uma condi√ß√£o `IF/THEN`, voc√™ usa este n√≥.
        1.  Ele pega a mensagem do usu√°rio.
        2.  Envia para o WorkersAI (ou outra API) junto com um **Prompt** que voc√™ define.
        3.  **Exemplo de Prompt:** "Voc√™ √© um assistente de vendas. Seu √∫nico objetivo √© agendar uma reuni√£o. O usu√°rio disse: `[Mensagem do Usu√°rio]`. O hist√≥rico da conversa √©: `[Hist√≥rico]`. O usu√°rio est√° na fase `[Tag]`. Responda de forma natural, fa√ßa a pr√≥xima pergunta necess√°ria para conseguir o Nome, Email e melhor Hor√°rio. Se j√° tiver tudo, proponha um hor√°rio."
        4.  O n√≥ recebe a resposta da IA.
        5.  O n√≥ "Enviar Mensagem" envia essa resposta da IA para o usu√°rio.

* **Tela: "Configura√ß√µes de IA"**
    * **Visual:** Campos de formul√°rio.
    * **Funcionalidades:**
        * Campo para a chave de API (OpenAI, Cloudflare, etc.).
        * Um campo de texto grande para o "Prompt Mestre" (a personalidade base do seu bot).

---

### 3. üó∫Ô∏è Roadmap de Desenvolvimento (MVP)

Voc√™ n√£o vai construir tudo isso de uma vez. Eu sugiro esta ordem:

1.  **MVP 1 (Prova de Conceito):**
    * Backend + Servi√ßo de Conex√£o (Baileys) rodando local.
    * Tela de "Conex√µes" (s√≥ para gerar o QR Code e ver o status).
    * Tela de "Caixa de Entrada" (simples, s√≥ para *responder manualmente*).
    * **Objetivo:** Provar que voc√™ consegue conectar e conversar manualmente.

2.  **MVP 2 (O Bot Est√°tico):**
    * M√≥dulo "Editor de Funil" (com n√≥s simples: Enviar Texto, Aguardar Resposta, Condi√ß√£o IF/THEN).
    * Um "Motor de Funil" no Backend que interpreta o JSON do editor e executa o funil.
    * M√≥dulo "Contatos" (s√≥ para ver quem est√° em qual funil).
    * **Objetivo:** Ter um chatbot de regras funcionando.

3.  **Vers√£o 1.0 (O Bot Inteligente):**
    * Adicionar o M√≥dulo "Caixa de Entrada" completo (com pausa/play do bot).
    * Adicionar o "N√≥ de IA" (WorkersAI) no Editor de Funil.
    * Adicionar o "N√≥ de Webhook" (para integrar com Calendly/Google Calendar e *de fato* agendar a reuni√£o).
    * **Objetivo:** Atingir seu objetivo final de agendamento de reuni√£o "humano".

Este √© um projeto de m√©dio a grande porte, mas incrivelmente poderoso se bem executado. O maior desafio t√©cnico ser√° manter o `Servi√ßo de Conex√£o` (Baileys) est√°vel e atualizado.

Posso ajudar a detalhar a arquitetura de comunica√ß√£o entre o **Backend** e o **Servi√ßo de Conex√£o (Baileys)**? (Dica: Webhooks e RabbitMQ/Redis seriam seus melhores amigos aqui).

Excelente escolha\! Aceitar a dica sobre RabbitMQ e Redis √© o que separa um "projeto de fim de semana" de uma "plataforma escal√°vel".

Voc√™ est√° correto: usar Webhooks diretos ou chamadas HTTP/WebSocket entre o `Backend` e o `Servi√ßo de Conex√£o` (Baileys) √© uma armadilha. Se o Conector cair, o Backend n√£o sabe. Se o Backend escalar, os Conectores n√£o sabem para qual inst√¢ncia ligar.

Vamos usar **RabbitMQ** para **Mensageria Ass√≠ncrona** (o "carteiro") e **Redis** para **Gerenciamento de Estado** (a "mem√≥ria de curto prazo").

Aqui est√° o detalhamento da arquitetura de comunica√ß√£o.

-----

### Vis√£o Geral da Arquitetura

Sua plataforma ter√° 4 componentes principais se comunicando:

1.  **`Backend` (A L√≥gica):** Sua API principal. Onde os funis s√£o definidos. (Ex: Node.js/Express, Python/Django).
2.  **`Servi√ßo de Conex√£o` (O "Operador"):** Uma (ou v√°rias) inst√¢ncias do Baileys. Cada inst√¢ncia √© um processo separado cuidando de *um* n√∫mero de WhatsApp.
3.  **`RabbitMQ` (O "Correio"):** O *Message Broker*. Ele desacopla o Backend dos Conectores. Eles nunca conversam diretamente entre si; eles apenas enviam e recebem "cartas" (mensagens) do RabbitMQ.
4.  **`Redis` (A "Mem√≥ria"):** Um banco de dados chave-valor ultrarr√°pido. Ele armazena o *estado atual* de tudo.

-----

### Fluxo 1: Mensagem CHEGANDO (Usu√°rio do WhatsApp -\> Backend)

Este √© o fluxo "RX" (Receive). O objetivo √© pegar a mensagem do Baileys e entreg√°-la ao seu Backend da forma mais confi√°vel poss√≠vel.

**M√©todo: Fila de Trabalho (Work Queue)**

1.  **O Usu√°rio** envia "Ol√°" para o n√∫mero A, que √© gerenciado pelo `Conector-A`.
2.  **O `Conector-A` (Baileys)** recebe a mensagem. Em vez de fazer um HTTP POST no seu backend (o que pode falhar), ele formata a mensagem em um JSON:
    ```json
    {
      "instance_id": "inst_123_do_alan",
      "timestamp": 1678886400,
      "from_number": "554199998888",
      "message_type": "text",
      "data": { "text": "Ol√°" }
    }
    ```
3.  **O `Conector-A`** *publica* (envia) essa mensagem JSON para uma *√∫nica fila* no RabbitMQ. Vamos cham√°-la de: **`queue-rx-incoming`** (Fila de Recebimento).
4.  **M√∫ltiplos `Conectores`** (Conector-A, Conector-B, Conector-C) fazem a mesma coisa. Todos publicam suas mensagens recebidas na *mesma* fila `queue-rx-incoming`.
5.  **O seu `Backend`** (que pode ter v√°rias inst√¢ncias rodando para escalar) atua como um *Consumidor* dessa fila.
6.  O RabbitMQ entrega as mensagens da fila `queue-rx-incoming` uma a uma para os workers do seu Backend (usando o padr√£o "Round Robin").
7.  **O `Backend`** recebe o JSON, processa a l√≥gica do funil (ex: "Ah, o usu√°rio 554199998888 disse 'Ol√°', preciso responder 'Oi, tudo bem?'"), e decide que precisa *enviar* uma resposta.

**Por que isso √© bom?**

  * **Resili√™ncia:** Se o seu `Backend` estiver offline ou sobrecarregado, as mensagens n√£o se perdem. Elas ficam enfileiradas no RabbitMQ esperando para serem processadas.
  * **Escalabilidade:** Voc√™ pode ter 1000 Conectores e 10 workers de Backend. O RabbitMQ gerencia a distribui√ß√£o da carga de trabalho perfeitamente.

-----

### Fluxo 2: Mensagem SAINDO (Backend -\> Usu√°rio do WhatsApp)

Este √© o fluxo "TX" (Transmit). √â a parte mais complexa e crucial. O Backend precisa dizer ao `Conector-A` (e *apenas* ao `Conector-A`) para enviar uma mensagem.

**M√©todo: Troca de T√≥pico (Topic Exchange)**

1.  **O `Backend`** decide que precisa enviar "Oi, tudo bem?" para o usu√°rio `554199998888`, que pertence √† inst√¢ncia `inst_123_do_alan`.
2.  O `Backend` *n√£o sabe* onde o `Conector-A` (que gerencia a `inst_123_do_alan`) est√° rodando. E n√£o precisa saber.
3.  O `Backend` *publica* uma mensagem JSON para uma **Exchange** (um "distribuidor") no RabbitMQ. Vamos cham√°-la de: **`exchange-tx-outgoing`**.
4.  A mensagem √© publicada com uma "chave de roteamento" (routing key) **√∫nica para o destinat√°rio**. A chave ser√°: **`send.inst_123_do_alan`**.
    ```json
    // Publicado na exchange 'exchange-tx-outgoing'
    // com a chave de roteamento 'send.inst_123_do_alan'
    {
      "target_number": "554199998888",
      "message_type": "text",
      "data": { "text": "Oi, tudo bem?", "simulate_typing": true }
    }
    ```
5.  **M√°gica do RabbitMQ:** Quando o `Conector-A` (o processo Baileys da `inst_123_do_alan`) iniciou, ele fez duas coisas:
      * Criou uma *fila exclusiva* s√≥ para ele (ex: `queue_inst_123_do_alan_temp`).
      * Ele disse ao RabbitMQ: "Por favor, envie todas as mensagens da exchange `exchange-tx-outgoing` que tenham a chave `send.inst_123_do_alan` para a minha fila exclusiva." (Isso se chama *binding*).
6.  **O RabbitMQ** recebe a mensagem do `Backend` na exchange, v√™ a chave `send.inst_123_do_alan`, e a roteia *exclusivamente* para a fila do `Conector-A`.
7.  **O `Conector-A`** est√° *escutando* (consumindo) sua fila exclusiva, recebe o JSON e executa a fun√ß√£o do Baileys para enviar a mensagem.

**Por que isso √© bom?**

  * **Desacoplamento Total:** O Backend s√≥ precisa saber o `instance_id`. Ele n√£o sabe IP, porta ou se o Conector est√° rodando em Docker, Kubernetes ou na m√°quina de um cliente.
  * **Entrega Direcionada:** Garante que apenas o processo Baileys correto receba a ordem de envio.
  * **Offline Handling:** Se o `Conector-A` estiver reiniciando (porque o Baileys quebrou), a mensagem "Oi, tudo bem?" fica esperando na fila exclusiva dele. Quando ele voltar, ele a processar√°.

-----

### Fluxo 3: O Papel do REDIS (Gerenciamento de Estado)

Se o RabbitMQ √© o "Correio", o Redis √© o "Bloco de Notas" / "Mem√≥ria de Curto Prazo" que todos podem ler e escrever rapidamente.

**O Redis deve armazenar dados vol√°teis (que mudam r√°pido):**

1.  **Status da Conex√£o:**

      * O `Servi√ßo de Conex√£o` (Baileys) deve constantemente atualizar seu status no Redis.
      * Ex: `SET status:inst_123_do_alan "CONNECTED"`
      * Ex: `SET status:inst_456 "AWAITING_QR_CODE"`
      * Quando seu `Frontend` (Painel) carregar, ele l√™ do Redis (via Backend) para mostrar os status em tempo real.

2.  **Trava de Conversa (Onde o usu√°rio est√° no funil):**

      * Isso √© **CRUCIAL** para voc√™.
      * Quando o `Backend` recebe uma mensagem (Fluxo 1), ele consulta o Redis: "Qual √© o estado atual do `554199998888`?"
      * Redis: `GET state:554199998888` -\> (retorna) `"funil_agendamento:etapa_2_pedindo_email"`
      * O `Backend` sabe que a resposta do usu√°rio √© o email. Ele processa, e atualiza o estado:
      * Redis: `SET state:554199998888 "funil_agendamento:etapa_3_pedindo_data"`

3.  **Controle de Atendimento Humano (Pausar o Bot):**

      * Quando o humano clica em "Assumir Conversa" no seu painel (M√≥dulo 3 da resposta anterior):
      * O `Backend` escreve no Redis: `SET bot_control:554199998888 "PAUSED_BY_HUMAN"`
      * Agora, no Fluxo 1, quando o `Backend` recebe uma mensagem, ele primeiro checa o Redis. Se estiver "PAUSED", ele *ignora* o funil e apenas salva a mensagem no hist√≥rico.

### Resumo da Arquitetura

| Componente | Ferramenta | Responsabilidade Principal |
| :--- | :--- | :--- |
| **Backend** | Node.js / Python | L√≥gica de funil, API para o Frontend, consumir da `queue-rx-incoming`, publicar na `exchange-tx-outgoing`. |
| **Conector** | Node.js (Baileys) | Manter conex√£o com o WhatsApp, publicar na `queue-rx-incoming`, consumir da *sua fila exclusiva* (vinda da exchange). |
| **Mensageria** | RabbitMQ | Roteamento de mensagens (RX e TX), resili√™ncia, desacoplamento. |
| **Estado** | Redis | Status da conex√£o (`status:inst_123`), Posi√ß√£o do usu√°rio no funil (`state:user_number`). |

Este design √© como as grandes plataformas (Twilio, Zenvia) operam por baixo dos panos. √â robusto, escal√°vel e resiliente √† natureza inst√°vel das conex√µes n√£o-oficiais.

O pr√≥ximo passo l√≥gico seria desenhar os modelos de dados (schemas) para o seu banco de dados principal (PostgreSQL/MongoDB) onde voc√™ armazenar√° os funis, contatos e hist√≥rico de chat. Quer explorar isso?

Vamos l√°, meu amigo\! Esta √© a funda√ß√£o do seu projeto. Uma boa modelagem de banco de dados √© o que vai permitir que seu sistema seja r√°pido, organizado e f√°cil de manter.

Como voc√™ mencionou, temos duas grandes rotas: **PostgreSQL (SQL)** ou **MongoDB (NoSQL)**.

  * **MongoDB (NoSQL):** Seria mais "livre". Voc√™ jogaria documentos (JSONs) l√° dentro. √â muito r√°pido para prototipar. A cole√ß√£o `contacts` seria simples (voc√™ poderia "embedar" tags e campos direto no documento do contato). A cole√ß√£o `messages` tamb√©m seria muito natural. O *problema* √© manter a consist√™ncia. O que acontece se voc√™ deletar um `workspace` e esquecer de deletar os `contacts` e `funnels` dele?
  * **PostgreSQL (SQL):** √â mais "r√≠gido", mas de um jeito bom. Ele nos for√ßa a organizar os dados com *rela√ß√µes* (Foreign Keys). Isso garante a **integridade referencial** (voc√™ n√£o consegue ter uma mensagem sem um contato, ou um contato sem um workspace).

**Minha Recomenda√ß√£o: PostgreSQL com `jsonb`**

Vamos usar o PostgreSQL, mas vamos pegar emprestada a melhor parte do NoSQL: o tipo `jsonb`. Com ele, teremos a rigidez e seguran√ßa do SQL para as rela√ß√µes e a flexibilidade do JSON para dados que n√£o t√™m uma estrutura fixa (como a defini√ß√£o do seu funil ou os campos personalizados).

Aqui est√° o desenho dos "schemas" (tabelas) que voc√™ precisar√°.

-----

### 1\. üè¢ M√≥dulo de Contas (Workspace e Usu√°rios)

Precisamos de um sistema multi-usu√°rio, onde voc√™ pode ter v√°rios "workspaces" (ou "empresas") e v√°rios usu√°rios (agentes) dentro de cada um.

#### `workspaces` (As "Contas" dos seus clientes)

```sql
CREATE TABLE workspaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- ID √∫nico do workspace
    name VARCHAR(100) NOT NULL,                   -- Ex: "Embracon - Vendas"
    owner_id UUID NOT NULL,                        -- Chave estrangeira para 'users', quem √© o dono
    created_at TIMESTAMPTZ DEFAULT now()
);
```

#### `users` (Usu√°rios da plataforma: Admins, Agentes)

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,            -- Para login
    name VARCHAR(100) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,           -- Criptografado!
    created_at TIMESTAMPTZ DEFAULT now()
);
```

*Note: Adicione a `owner_id` em `workspaces` depois que a tabela `users` for criada.*

#### `workspace_members` (Tabela-piv√¥: Quem pertence a qual workspace)

```sql
CREATE TABLE workspace_members (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'agent', -- Ex: 'admin', 'agent'
    PRIMARY KEY (user_id, workspace_id)      -- Um usu√°rio s√≥ pode estar 1x em cada workspace
);
```

-----

### 2\. üîå M√≥dulo de Conex√µes (Inst√¢ncias do WhatsApp)

Onde voc√™ armazena as contas de WhatsApp que foram conectadas via Baileys.

#### `instances` (As conex√µes/n√∫meros de WhatsApp)

```sql
CREATE TABLE instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Este √© o 'instance_id' que usamos na arquitetura!
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,                   -- Ex: "Bot Vendas 1"
    phone_number VARCHAR(30),                     -- O n√∫mero (quando j√° conectado)
    -- O ESTADO (CONNECTED, AWAITING_QR) fica no REDIS.
    -- O SESSION_DATA (tokens) fica no volume do Conector Baileys.
    -- Este banco √© s√≥ para a configura√ß√£o.
    created_at TIMESTAMPTZ DEFAULT now()
);
```

-----

### 3\. üë• M√≥dulo de Contatos (O Mini-CRM)

Os leads que conversam com seus bots.

#### `tags` (Etiquetas para organizar contatos)

```sql
CREATE TABLE tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    color VARCHAR(7) DEFAULT '#CCCCCC',           -- Ex: "#FF0000"
    UNIQUE(workspace_id, name)                    -- N√£o pode ter tags com mesmo nome no workspace
);
```

#### `contacts` (Os leads/clientes finais)

```sql
CREATE TABLE contacts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    instance_id UUID NOT NULL REFERENCES instances(id) ON DELETE CASCADE,
    phone_number VARCHAR(30) NOT NULL,            -- N√∫mero do lead
    name VARCHAR(150),                            -- Nome (do perfil do WA ou salvo)
    
    -- Aqui est√° a m√°gica do 'jsonb' para campos personalizados!
    -- Voc√™ pode salvar: {"email": "...", "cidade": "...", "funil_etapa": "3"}
    custom_data JSONB DEFAULT '{}' NOT NULL,
    
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(instance_id, phone_number)             -- Um n√∫mero s√≥ pode ser 1 contato por inst√¢ncia
);
```

#### `contact_tags` (Tabela-piv√¥: Quais tags um contato possui)

```sql
CREATE TABLE contact_tags (
    contact_id UUID REFERENCES contacts(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
    PRIMARY KEY (contact_id, tag_id)
);
```

-----

### 4\. üß† M√≥dulo de Funis (O "Pipeline Faseado")

O cora√ß√£o do seu projeto.

#### `funnels` (Os fluxos de conversa)

```sql
CREATE TABLE funnels (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    name VARCHAR(150) NOT NULL,                   -- Ex: "Funil de Agendamento"
    
    -- O CAMPO MAIS IMPORTANTE
    -- Armazena o JSON gigante do seu editor visual (n√≥s, conex√µes, etc.)
    definition JSONB DEFAULT '{}' NOT NULL,
    
    -- Gatilhos simples
    trigger_keyword VARCHAR(100),                 -- Ex: "vendas", "agendar"
    is_active BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT now()
);
```

-----

### 5\. üí¨ M√≥dulo de Mensagens (Caixa de Entrada e Hist√≥rico)

Onde o chat *realmente* acontece. Esta tabela ser√° a **maior e mais acessada** do seu banco.

#### `messages`

```sql
CREATE TABLE messages (
    id BIGSERIAL PRIMARY KEY,                     -- Um n√∫mero sequencial √© bom para ordem
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    instance_id UUID NOT NULL REFERENCES instances(id) ON DELETE CASCADE,
    
    -- 'IN' (do usu√°rio para voc√™), 'OUT' (de voc√™ para o usu√°rio)
    message_direction VARCHAR(3) NOT NULL CHECK (message_direction IN ('IN', 'OUT')),
    
    message_type VARCHAR(20) NOT NULL,            -- 'text', 'image', 'audio', 'button_reply'
    
    -- O conte√∫do da mensagem (texto, URL da m√≠dia, etc.)
    message_data JSONB NOT NULL,
    
    -- Rastreabilidade: Quem/O que enviou esta mensagem?
    agent_id UUID REFERENCES users(id),           -- NULL se for bot, ID do agente se for humano
    funnel_id UUID REFERENCES funnels(id),        -- NULL se for humano, ID do funil se for bot
    
    timestamp TIMESTAMPTZ DEFAULT now()           -- Quando a mensagem foi recebida/enviada
);

-- ESSENCIAL: √çndices para carregar o chat r√°pido
CREATE INDEX idx_messages_contact_id ON messages (contact_id);
CREATE INDEX idx_messages_timestamp ON messages (timestamp);
```

### Alternativa MongoDB (Para Compara√ß√£o)

S√≥ para voc√™ ver, em Mongo, a cole√ß√£o `contacts` seria muito mais simples (mas menos "segura" em termos de dados):

```json
// Cole√ß√£o "contacts" no MongoDB
{
  "_id": ObjectId("..."),
  "workspace_id": ObjectId("..."),
  "instance_id": ObjectId("..."),
  "phone_number": "554199998888",
  "name": "Alan Evangelista",
  // Tags s√£o apenas um array de strings (simples, mas sem valida√ß√£o)
  "tags": ["Lead Quente", "Dev"],
  // Campos personalizados s√£o livres
  "custom_data": {
    "email": "alan@embracon.com.br",
    "cidade": "Fazenda Rio Grande",
    "funil_etapa": "aguardando_horario"
  },
  "created_at": "..."
}
```

Como pode ver, o modelo Postgres (SQL) com `jsonb` em `contacts.custom_data` e `funnels.definition` lhe d√° o melhor dos dois mundos: a estrutura relacional E a liberdade do JSON.

O pr√≥ximo passo √© definir a "camada" que fica entre o banco e o mundo exterior. Voc√™ gostaria de detalhar a **API (os endpoints)** que seu `Backend` precisaria ter para gerenciar esses dados? (Ex: `POST /funnels`, `GET /contacts/:id`, etc.)

Meu amigo, **agora sim**. Voc√™ n√£o est√° mais apenas explorando, voc√™ est√° conectando os pontos. O que voc√™ me trouxe (a arquitetura, os m√≥dulos 1-5, o RabbitMQ/Redis) √© a *funda√ß√£o de engenharia correta*.

O que voc√™ adicionou agora (ManyChat, Odoo, Agentes, WorkersAI, funil de agendamento) √© a *vis√£o de neg√≥cio* e a *intelig√™ncia* que v√£o rodar em cima dessa funda√ß√£o.

Voc√™ est√° 100% correto. O terminal √© s√≥ para provar que a conex√£o funciona. O QR Code *deve* estar no Frontend. E sim, tudo deve ser multi-inst√¢ncia e multi-agente.

Vamos montar o **"Desenho de Engenharia Perfeito"** fundindo tudo isso.

-----

### 1\. üèõÔ∏è A Arquitetura Conceitual (O Mapa Completo)

Este √© o desenho do seu ecossistema. Note os novos atores que voc√™ trouxe: **Atendentes**, **WorkersAI** e **Odoo**.

```
+------------------+
|                  |
|   USU√ÅRIO (APP)  <---- (WhatsApp) ----> [SERVI√áO DE CONEX√ÉO (Baileys)]
|                  |                         ^  |
+------------------+                         |  | (RabbitMQ)
                                             |  v
+------------------+     (API HTTP/S)     +---------+     (RabbitMQ)     +------------------+
|                  |                      |         |                      |                  |
|   FRONTEND       <----------------------> BACKEND | <------------------> | REDIS (Estado)   |
| (React/Vue)      |                      | (API)   |                      | (Sess√£o, Fila,  |
| - Telas/M√≥dulos  |                      +---------+                      |  Controle do Bot) |
| - Caixa de Entrada|                         |  |                         +------------------+
| - Editor de Funil |                         |  | (SQL)
|                  |                         |  v
+------------------+                         +------------------+
|     ATENDENTE    |                         | POSTGRESQL (BD)  |
| (Humano)         |                         | (Contatos, Msgs, |
|                  |                         |  Funis, Agentes) |
+------------------+                         +------------------+
                                                 |
                                                 | (API Externa)
                                                 v
                                 [WorkersAI (IA)]   [Odoo (CRM)]
```

-----

### 2\. üíª O Roadmap de M√≥dulos & Telas (A Vers√£o "Upgrade")

Aqui est√° a lista de m√≥dulos (telas) refinada, incorporando **todas** as suas novas exig√™ncias.

#### M√≥dulo 1: Gest√£o de Conex√µes (Inst√¢ncias)

  * **Telas:** `Conex√µes`, `Modal de Conex√£o`.
  * **Fun√ß√µes Base:**
      * Listar todas as inst√¢ncias (n√∫meros de WA) do workspace.
      * Ver status (`Conectado`, `Desconectado`, `Aguardando QR`). O status √© lido do **Redis** (`status:inst_123`).
      * Bot√£o "Adicionar Inst√¢ncia" -\> Abre o modal `Modal de Conex√£o`.
      * **Tela (Modal de Conex√£o):**
          * O Frontend pede ao Backend: "preciso de um QR Code para uma nova inst√¢ncia".
          * O Backend comanda (via RabbitMQ) o *Sistema de Conectores* para iniciar um novo processo Baileys.
          * Esse processo gera o QR Code e informa o Backend (via RabbitMQ).
          * O Backend envia o QR Code para o Frontend via WebSocket/Polling.
          * O Frontend exibe o QR Code.
      * Bot√£o "Remover Inst√¢ncia" (Desconecta e apaga).

#### M√≥dulo 2: Gest√£o de Equipe (Atendentes)

  * **Telas:** `Equipe`, `Fun√ß√µes e Permiss√µes`.
  * **Fun√ß√µes (Feature Nova):**
      * Listar todos os `users` (atendentes) do `workspace`.
      * Convidar novo atendente (por email).
      * Definir permiss√µes (ex: "Admin", "Agente", "Supervisor").
      * Criar "Departamentos" ou "Times" (ex: "Vendas", "Suporte"). Isso √© crucial para o roteamento.

#### M√≥dulo 3: Contatos e CRM Interno

  * **Telas:** `Lista de Contatos`, `Detalhe do Contato`.
  * **Fun√ß√µes (Upgrade):**
      * Listar todos os contatos de *todas* as inst√¢ncias.
      * Filtrar por `Tag`, `Atendente Respons√°vel`, `Inst√¢ncia (N√∫mero)`.
      * **Tela (Detalhe do Contato):**
          * Coluna 1 (Dados): `Nome`, `N√∫mero`, `Email`, `Atendente Respons√°vel`.
          * Campos Personalizados (do `jsonb`): `Cidade`, `Empresa`, etc.
          * **Campo Chave (Novo):** `Fase do Funil` (ex: "Qualifica√ß√£o", "Aguardando Agendamento", "Agendado", "Cliente"). Este campo √© atualizado pelo funil (M√≥dulo 5).
          * `Tags` (ex: "lead\_frio", "oportunidade").

#### M√≥dulo 4: Caixa de Entrada Unificada (Atendimento Humano)

  * **Telas:** `Caixa de Entrada (Inbox)`.
  * **Fun√ß√µes (Upgrade Cr√≠tico):**
      * **Visual:** 3 colunas (Lista de Chats, Chat Ativo, Dados do Contato).
      * **Fun√ß√£o:** As mensagens da `queue-rx-incoming` (RabbitMQ) chegam no Backend, s√£o salvas no **PostgreSQL** e exibidas no Frontend em tempo real (via WebSocket).
      * **Garantia de Banimento:** Como as mensagens s√£o salvas no *seu* PostgreSQL, **mesmo que a conta do WA seja banida, o hist√≥rico da conversa est√° 100% salvo** e vis√≠vel aqui.
      * **Roteamento (Novo):**
          * Novos chats caem numa fila "N√£o Atribu√≠do".
          * Um supervisor ou o pr√≥prio agente pode "Pegar" o chat.
          * Um funil pode *automaticamente* atribuir um chat a um "Departamento" (ex: se o usu√°rio digitou "vendas").
      * **Pausar Bot:** O bot√£o "Pausar Bot" (que seta o `bot_control:numero` no Redis) √© a funcionalidade mais importante. Permite ao humano assumir sem que o bot atrapalhe.
      * **Enviar Mensagem:** O atendente digita, o Frontend manda para o Backend (API), o Backend publica na `exchange-tx-outgoing` (RabbitMQ) com a `routing_key` correta.

#### M√≥dulo 5: Editor de Funil Visual (Flow Builder)

  * **Telas:** `Lista de Funis`, `Editor de Funil (Canvas)`.
  * **Fun√ß√µes (O C√©rebro - Upgrade com IA e CRM):**
      * Canvas visual para arrastar e soltar "N√≥s".
      * **N√≥s Essenciais (Baseado no ManyChat):**
          * `Gatilho`: (Keyword, Primeira Mensagem, Tag Adicionada).
          * `Enviar Mensagem`: (Texto, Imagem, √Åudio, Bot√µes, Listas).
          * `Aguardar Resposta`: (Salva a resposta em uma vari√°vel).
          * `Condi√ß√£o (IF/THEN)`: (Verifica a resposta/vari√°vel).
          * `Atraso`: (Simula digita√ß√£o e espera humana).
          * `A√ß√£o: Adicionar Tag`.
          * `A√ß√£o: Atribuir Atendente`: (Manda o chat para um agente/departamento no M√≥dulo 4).
      * **N√≥s Inteligentes (O "Upgrade"):**
          * **N√≥: `Qualificar com IA` (WorkersAI):**
              * Pega a mensagem do usu√°rio (ex: "queria saber o pre√ßo").
              * Envia para o **WorkersAI** com um prompt: "Voc√™ √© um SDR. O usu√°rio disse: `[msg]`. O hist√≥rico √© `[hist]`. A fase dele √© `[fase_funil]`. Seu objetivo √© coletar NOME, EMAIL e confirmar se ele quer AGENDAR. Responda de forma natural."
              * A IA responde (ex: "Claro\! Para qual e-mail posso enviar a proposta?").
              * O funil envia essa resposta da IA.
              * O funil entra em loop nesse n√≥ at√© que a IA retorne um JSON indicando "Qualifica√ß√£o Conclu√≠da".
          * **N√≥: `Enviar para Odoo` (Integra√ß√£o):**
              * Quando o funil ou a IA identificam que o lead est√° qualificado (ex: `fase_funil` == "Agendado").
              * Este n√≥ pega os dados (Nome, Email, Telefone, Hist√≥rico) e faz um POST na API do **Odoo** para criar um novo "Lead" ou "Oportunidade".

-----

### 3\. üó∫Ô∏è O Roadmap de Implementa√ß√£o (MVP 2.0)

A ordem que voc√™ tinha estava boa. Vamos refin√°-la com as novas features:

1.  **MVP 1 (Prova de Conceito):**

      * **Telas:** M√≥dulo 1 (Conex√µes) + M√≥dulo 4 (Caixa de Entrada - *super simples*).
      * **Infra:** Backend, 1 Conector (Baileys), RabbitMQ, Redis, Postgres.
      * **Objetivo:** Conectar 1 n√∫mero pelo Frontend (QR Code) e ser capaz de enviar/receber mensagens *manualmente* pela Caixa de Entrada. **Prova que a arquitetura de mensageria (Fluxo RX/TX) funciona.**

2.  **MVP 2 (O Bot de Regras):**

      * **Telas:** M√≥dulo 5 (Editor de Funil - *simples*) + M√≥dulo 3 (Contatos).
      * **Fun√ß√µes:** Implementar o "Motor de Funil" no Backend.
      * **N√≥s:** `Gatilho (Keyword)`, `Enviar Mensagem`, `Condi√ß√£o (IF/THEN)`.
      * **Objetivo:** Criar um funil simples (ex: "Ol√°" -\> "Tudo bem?"). **Prova que o motor de funil e o `state:numero` no Redis funcionam.**

3.  **Vers√£o 1.0 (O Produto M√≠nimo Vi√°vel - O seu objetivo):**

      * **Telas:** M√≥dulo 2 (Gest√£o de Equipe) + M√≥dulo 4 (Caixa de Entrada *completa*).
      * **Fun√ß√µes:**
          * Adicionar Agentes.
          * Roteamento de chats (manual e autom√°tico).
          * Bot√£o "Pausar Bot".
      * **N√≥s do Funil:** Adicionar o n√≥ `Qualificar com IA (WorkersAI)` e o n√≥ `Enviar para Odoo`.
      * **Objetivo:** Ter um sistema onde m√∫ltiplos agentes podem atender m√∫ltiplos n√∫meros, e o bot de IA qualifica leads e os envia para o Odoo para agendamento.

Este √© o desenho completo. √â uma plataforma robusta, escal√°vel e que atende exatamente ao problema de neg√≥cio que voc√™ descreveu.

O pr√≥ximo passo l√≥gico √© definir a **API (os endpoints)** que o Backend precisar√° expor para o Frontend consumir, come√ßando pelo M√≥dulo 1.

Posso detalhar os endpoints da API REST/WebSocket necess√°rios para o **MVP 1** (M√≥dulo 1: Conex√µes e M√≥dulo 4: Chat)?

Com certeza. Este √© o "desenho" (o contrato da API) que seu `Frontend` (React/Vue) usar√° para conversar com seu `Backend` (Node/API).

Este design √© dividido em duas partes:

1.  **API REST (HTTP):** Usada para **buscar dados** (carregar hist√≥rico, listas) e **iniciar a√ß√µes** (criar uma conex√£o).
2.  **API WebSocket (Real-Time):** Usada para **eventos em tempo real** (receber QR code, receber nova mensagem, enviar nova mensagem).

O `Backend` rodar√° na porta `3001` (ex: `http://localhost:3001`) e o `Frontend` na `3000`.

-----

### 1\. Autentica√ß√£o (Necess√°rio antes de tudo)

Seu `Frontend` precisar√° se autenticar para provar quem ele √©.

#### `POST /api/v1/auth/login`

  * **O que faz:** Autentica um usu√°rio (atendente) na plataforma.
  * **Body (JSON):** `{ "email": "...", "password": "..." }`
  * **Resposta:** `{ "access_token": "jwt.token.aqui" }`
  * **A√ß√£o:** O `Frontend` deve salvar este token e envi√°-lo em *todas* as futuras requisi√ß√µes no Header `Authorization: Bearer jwt.token.aqui`.

-----

### 2\. M√≥dulo 1: Gerenciamento de Conex√µes (MVP 1)

O fluxo para adicionar um novo n√∫mero de WhatsApp.

#### API REST (Para carregar dados e iniciar a√ß√µes)

#### `GET /api/v1/instances`

  * **O que faz:** Lista todas as conex√µes (n√∫meros de WA) do workspace.
  * **Resposta:**
    ```json
    [
      {
        "id": "inst_123",
        "name": "Bot Vendas 1",
        "status": "CONNECTED", // LIDO DO REDIS
        "phone_number": "554199998888"
      },
      {
        "id": "inst_456",
        "name": "Bot Suporte",
        "status": "AWAITING_QR_CODE" // LIDO DO REDIS
      }
    ]
    ```

#### `POST /api/v1/instances`

  * **O que faz:** Inicia o processo de cria√ß√£o de uma nova conex√£o.
  * **Body (JSON):** `{ "name": "Minha Nova Conex√£o" }`
  * **A√ß√£o do Backend:**
    1.  Cria a `instance` no **PostgreSQL**.
    2.  Publica uma mensagem no **RabbitMQ** mandando o `Servi√ßo de Conex√£o` "subir" um novo processo Baileys para este ID.
  * **Resposta:** `{ "id": "inst_789", "name": "Minha Nova Conex√£o", "status": "PENDING" }`

#### `DELETE /api/v1/instances/:instanceId`

  * **O que faz:** Desconecta e remove uma inst√¢ncia.
  * **A√ß√£o do Backend:** Manda uma mensagem (via RabbitMQ) para o `Conector` desligar e apaga a sess√£o.

#### API WebSocket (Para eventos em tempo real)

O `Frontend` deve se conectar ao servidor WebSocket do `Backend` (ex: `ws://localhost:3001`) logo ap√≥s o login.

**Evento: `instance:qr_code` (Backend -\> Frontend)**

  * **Quando acontece:** Logo ap√≥s o `POST /api/v1/instances`, o `Conector` gera o QR code, envia ao `Backend` (via RabbitMQ), e o `Backend` o retransmite para o `Frontend`.
  * **Payload (JSON):**
    ```json
    {
      "instanceId": "inst_789",
      "qr": "data:image/png;base64,iVBORw0KGgoAAAA... (string base64 do QR code)"
    }
    ```
  * **A√ß√£o do Frontend:** Exibe a imagem do QR code no "Modal de Conex√£o".

**Evento: `instance:status_change` (Backend -\> Frontend)**

  * **Quando acontece:** Quando o status de uma conex√£o muda (usu√°rio leu o QR, celular desconectou, etc.).
  * **Payload (JSON):**
    ```json
    {
      "instanceId": "inst_789",
      "status": "CONNECTED",
      "phone_number": "554198887777"
    }
    ```
  * **A√ß√£o do Frontend:** Fecha o modal do QR code e atualiza a lista de conex√µes (o item `inst_789` agora est√° `CONNECTED`).

-----

### 3\. M√≥dulo 4: Caixa de Entrada (MVP 1)

O fluxo para conversar manualmente.

#### API REST (Para carregar hist√≥rico)

#### `GET /api/v1/chats`

  * **O que faz:** Pega a "Lista de Chats" da Caixa de Entrada.
  * **Query Params (Filtros):** `?status=open`, `?agentId=...`, `?instanceId=...`
  * **Resposta:** (Lista de contatos que t√™m conversas, ordenados pela √∫ltima mensagem).
    ```json
    [
      {
        "contact_id": "contact_uuid_1",
        "name": "Lead A",
        "phone_number": "5541911112222",
        "last_message": "Ol√°, tudo bem?",
        "timestamp": "...",
        "unread_count": 2
      }
    ]
    ```

#### `GET /api/v1/chats/:contactId/messages`

  * **O que faz:** Pega o hist√≥rico de mensagens de um chat espec√≠fico (quando o atendente clica nele).
  * **Query Params (Pagina√ß√£o):** `?page=1`, `?limit=50`
  * **Resposta:** (Array de mensagens, salvas no **PostgreSQL**).
    ```json
    [
      {
        "id": "msg_1",
        "message_direction": "IN", // Usu√°rio mandou
        "message_type": "text",
        "message_data": { "text": "Ol√°, queria um or√ßamento" },
        "timestamp": "..."
      },
      {
        "id": "msg_2",
        "message_direction": "OUT", // Voc√™ mandou
        "message_type": "text",
        "message_data": { "text": "Claro, qual seu nome?" },
        "agent_id": "agent_uuid_alan", // Mostra que foi um humano
        "timestamp": "..."
      }
    ]
    ```

#### API WebSocket (Para enviar e receber em tempo real)

**Evento: `chat:new_message` (Backend -\> Frontend)**

  * **Quando acontece:** (Fluxo RX) Um usu√°rio do WhatsApp envia uma mensagem. O `Conector` a pega, joga no `queue-rx-incoming` (RabbitMQ). O `Backend` consome, salva no **PostgreSQL** e imediatamente dispara este evento.
  * **Payload (JSON):** (O objeto da mensagem que acabou de ser salva no banco).
    ```json
    {
      "id": "msg_3",
      "contact_id": "contact_uuid_1",
      "instance_id": "inst_123",
      "message_direction": "IN",
      "message_type": "text",
      "message_data": { "text": "Meu nome √© Alan" },
      "timestamp": "..."
    }
    ```
  * **A√ß√£o do Frontend:** Se o chat `contact_uuid_1` estiver aberto, anexa a mensagem. Se n√£o, atualiza a `Lista de Chats` com `unread_count: 3`.

**Evento: `chat:send_message` (Frontend -\> Backend)**

  * **Quando acontece:** (Fluxo TX) O atendente humano digita uma mensagem na Caixa de Entrada e aperta "Enviar".
  * **Payload (JSON):**
    ```json
    {
      "instanceId": "inst_123", // Para qual n√∫mero de WA enviar
      "target_number": "5541911112222", // Para qual cliente
      "message_type": "text",
      "data": { "text": "Obrigado Alan, qual seu email?" }
    }
    ```
  * **A√ß√£o do Backend:**
    1.  Recebe o evento WebSocket.
    2.  Salva a mensagem no **PostgreSQL** (com `message_direction: 'OUT'`, `agent_id: 'id_do_agente_logado'`).
    3.  Publica a mensagem na `exchange-tx-outgoing` (RabbitMQ) com a `routing_key: 'send.inst_123'`.
    4.  O `Conector` (Baileys) pega e envia para o WhatsApp.
    5.  (Opcional) O Backend pode re-emitir a mensagem salva (com o ID do banco) para o Frontend, para que o "tick" de enviado mude para "salvo".

Este "desenho" de API cobre perfeitamente o MVP 1. Ele √© ass√≠ncrono, escal√°vel e resiliente, pois toda a comunica√ß√£o cr√≠tica passa pelos WebSockets e pela infra de mensageria (RabbitMQ) que definimos.

O pr√≥ximo passo seria focar nas telas e l√≥gica do **MVP 2** (M√≥dulo 5: O Editor de Funil Visual). Voc√™ gostaria de detalhar a API para **salvar e executar** um funil?

Perfeito. Vamos detalhar o **MVP 2: O Bot Est√°tico**.

O MVP 1 provou a **comunica√ß√£o**: o `Frontend` fala com o `Backend`, que fala com o `Conector` (via RabbitMQ/Redis), e a `Caixa de Entrada` (Inbox) funciona manualmente.

O MVP 2 vai provar a **automa√ß√£o**: o `Backend` agora ter√° um "c√©rebro" (o **Motor de Funil**) que reage sozinho √†s mensagens, baseado em regras visuais que voc√™ vai criar no `Frontend`.

O foco √© total no **M√≥dulo 5 (Editor de Funil)** e no **M√≥dulo 3 (Contatos)**.

-----

### 1\. üß† O "Motor de Funil" (A Nova L√≥gica do Backend)

Este n√£o √© um endpoint de API, mas sim a *nova l√≥gica de servi√ßo* que seu `Backend` ganhar√°.

**Como funciona (Fluxo RX - Mensagem Chegando):**

1.  A mensagem do usu√°rio chega na fila `queue-rx-incoming` (RabbitMQ), como no MVP 1.
2.  O `Backend` consome a mensagem.
3.  **L√≥gica Antiga (MVP 1):** O `Backend` salva no `PostgreSQL` (tabela `messages`) e envia via WebSocket para a `Caixa de Entrada` (M√≥dulo 4).
4.  **L√ìGICA NOVA (MVP 2):** *Imediatamente ap√≥s* salvar, o `Backend` passa a mensagem para o "Motor de Funil".
5.  **O Motor de Funil ent√£o decide:**
    a.  **Checagem 1 (Controle Humano):** Ele consulta o **Redis**: `GET bot_control:554199998888`.
    b.  Se o valor for `"PAUSED_BY_HUMAN"`, o motor **para aqui**. O bot est√° pausado.
    c.  **Checagem 2 (Estado da Conversa):** Ele consulta o **Redis**: `GET state:554199998888`.
    d.  **Caso A: `state` √© `null` (Nova Conversa):**
    i.  O motor consulta o `PostgreSQL`: "Existe algum `funnel` (`is_active: true`) cujo `trigger_keyword` bate com a mensagem 'Ol√°'?"
    ii. Se sim, ele carrega o `definition` (JSON) desse funil.
    iii. Ele seta o estado no **Redis**: `SET state:554199998888 '{"funnel_id": "funil_abc", "current_node_id": "node_start"}'`.
    iv. Ele come√ßa a executar os n√≥s do funil.
    e.  **Caso B: `state` N√ÉO √© `null` (Conversa em Andamento):**
    i.  O Redis retorna: `{"funnel_id": "funil_abc", "current_node_id": "node_wait_1"}`.
    ii. O motor entende: "O usu√°rio estava no funil 'abc', parado no n√≥ 'esperando resposta 1'".
    iii. A mensagem atual ("Sim, tenho interesse") √© a resposta para esse n√≥.
    iv. O motor carrega o `definition` do funil 'abc', vai direto para o n√≥ `node_wait_1` e continua a execu√ß√£o.

**Como o Motor Executa os N√≥s (Exemplo):**

  * **N√≥ `Enviar Mensagem`:** O motor cria o JSON de envio (como no MVP 1) e o publica na `exchange-tx-outgoing` (RabbitMQ) para o `Conector` enviar.
  * **N√≥ `Aguardar Resposta`:** O motor atualiza o estado no **Redis** (ex: `SET state:.. '{"...": "node_wait_2"}'`) e **para a execu√ß√£o** (at√© a pr√≥xima mensagem do usu√°rio).
  * **N√≥ `Condi√ß√£o (IF/THEN)`:** O motor avalia a √∫ltima mensagem (ex: `message.text.includes("sim")`) e decide qual o pr√≥ximo n√≥ a ser executado.
  * **N√≥ `Adicionar Tag` (Novo):** O motor executa uma query no `PostgreSQL` para ligar uma `tag` a um `contact` (na tabela `contact_tags`).

-----

### 2\. üíª Telas e API (O "Desenho" do MVP 2)

Isto √© o que seu `Frontend` (M√≥dulo 3 e 5) usar√° para se comunicar com o `Backend`.

#### M√≥dulo 5: API de Funis (O Editor Visual)

O `Frontend` ter√° uma tela (`/funnels`) para listar os funis e outra (`/funnels/:id`) com um canvas (usando bibliotecas como **React Flow** ou **LiteGraph.js**) para desenhar o fluxo.

#### `GET /api/v1/funnels`

  * **O que faz:** Lista todos os funis do workspace.
  * **Resposta:**
    ```json
    [
      {
        "id": "funnel_abc",
        "name": "Funil de Boas-Vindas",
        "is_active": true,
        "trigger_keyword": "ola"
      },
      {
        "id": "funnel_xyz",
        "name": "Funil de Qualifica√ß√£o",
        "is_active": false,
        "trigger_keyword": "vendas"
      }
    ]
    ```

#### `GET /api/v1/funnels/:funnelId`

  * **O que faz:** Busca o JSON de um funil espec√≠fico para carreg√°-lo no editor visual.
  * **Resposta:** (Este √© o JSON da coluna `funnels.definition` no `PostgreSQL`)
    ```json
    {
      "id": "funnel_abc",
      "name": "Funil de Boas-Vindas",
      "trigger_keyword": "ola",
      "is_active": true,
      "definition": {
        "nodes": [
          { "id": "node_start", "type": "trigger", "data": { "keyword": "ola" }, "position": {"x": 0, "y": 0} },
          { "id": "node_send_1", "type": "sendMessage", "data": { "text": "Oi! Tudo bem?" }, "position": {"x": 200, "y": 0} },
          { "id": "node_wait_1", "type": "waitReply", "data": {}, "position": {"x": 400, "y": 0} },
          { "id": "node_if_1", "type": "condition", "data": { "condition": "response.text == 'sim'" }, "position": {"x": 600, "y": 0} },
          { "id": "node_send_2a", "type": "sendMessage", "data": { "text": "√ìtimo!" }, "position": {"x": 800, "y": -50} },
          { "id": "node_send_2b", "type": "sendMessage", "data": { "text": "Que pena." }, "position": {"x": 800, "y": 50} }
        ],
        "edges": [
          { "id": "e1", "source": "node_start", "target": "node_send_1" },
          { "id": "e2", "source": "node_send_1", "target": "node_wait_1" },
          { "id": "e3", "source": "node_wait_1", "target": "node_if_1" },
          { "id": "e4", "source": "node_if_1", "sourceHandle": "true_output", "target": "node_send_2a" },
          { "id": "e5", "source": "node_if_1", "sourceHandle": "false_output", "target": "node_send_2b" }
        ]
      }
    }
    ```

#### `POST /api/v1/funnels`

  * **O que faz:** Cria um novo funil (vazio).
  * **Body (JSON):** `{ "name": "Novo Funil" }`
  * **Resposta:** `{ "id": "funnel_new_id", "name": "Novo Funil", "definition": {} }`

#### `PUT /api/v1/funnels/:funnelId`

  * **O que faz:** **O endpoint mais importante do MVP 2.** Salva o desenho do funil.
  * **A√ß√£o:** O `Frontend` (React Flow) exporta o estado do canvas como JSON. O `Frontend` envia esse JSON gigante no *body* da requisi√ß√£o.
  * **Body (JSON):** (O mesmo JSON da resposta do `GET /api/v1/funnels/:funnelId` acima)
  * **A√ß√£o do Backend:** Valida o JSON e o salva na coluna `funnels.definition` (tipo `jsonb`) no `PostgreSQL`.
  * **Resposta:** `{ "success": true }`

-----

#### M√≥dulo 3: API de Contatos (O Mini-CRM)

O `Frontend` ter√° uma tela (`/contacts`) para listar os leads e (`/contacts/:id`) para ver seus detalhes (incluindo as tags que o bot adicionou).

#### `GET /api/v1/contacts`

  * **O que faz:** Lista os contatos para a tela de CRM.
  * **Query Params (Filtros):** `?tagId=tag_abc` (filtrar por tag), `?search=alan` (buscar por nome/n√∫mero).
  * **Resposta:**
    ```json
    [
      {
        "id": "contact_uuid_1",
        "name": "Alan Evangelista",
        "phone_number": "554199998888",
        "tags": [
          { "id": "tag_abc", "name": "Lead Frio", "color": "#0000FF" }
        ],
        "last_message_at": "..."
      }
    ]
    ```

#### `GET /api/v1/contacts/:contactId`

  * **O que faz:** Carrega a tela de "Detalhe do Contato".
  * **Resposta:**
    ```json
    {
      "id": "contact_uuid_1",
      "name": "Alan Evangelista",
      "phone_number": "554199998888",
      "tags": [
         { "id": "tag_abc", "name": "Lead Frio", "color": "#0000FF" }
      ],
      "custom_data": { // Lidos do JSONB
        "email": "alan@exemplo.com"
      },
      "current_funnel_state": { // LIDO DO REDIS!
        "funnel_id": "funnel_abc",
        "current_node_id": "node_wait_1"
      }
    }
    ```
    *(Nota: A tela de Detalhe do Contato tamb√©m exibir√° o hist√≥rico de chat, que √© o endpoint `GET /api/v1/chats/:contactId/messages` que j√° criamos no MVP 1).*

#### `PUT /api/v1/contacts/:contactId`

  * **O que faz:** Permite que um humano edite manualmente os dados do lead (nome, email, etc.).
  * **Body (JSON):** `{ "name": "Alan (Qualificado)", "custom_data": { "email": "novo@email.com" } }`
  * **Resposta:** `{ "success": true }`

Com isso, o MVP 2 est√° completo. Voc√™ ter√° um sistema onde:

1.  Voc√™ pode *desenhar* um funil de regras no Frontend.
2.  Voc√™ pode *salvar* esse funil no Backend.
3.  O `Motor de Funil` no Backend *executa* esse funil automaticamente quando um lead manda a keyword.
4.  O `Redis` *controla* em que etapa do funil o lead est√°.

O pr√≥ximo passo l√≥gico √© a **Vers√£o 1.0**, que voc√™ definiu: adicionar o `N√≥ de IA (WorkersAI)` e o `N√≥ de Integra√ß√£o (Odoo)` ao editor de funil, al√©m de melhorar a `Caixa de Entrada` com o M√≥dulo de `Equipes/Atendentes`.

Quer detalhar a engenharia da **Vers√£o 1.0**, focando na integra√ß√£o com WorkersAI e Odoo?

OK, meu amigo. Foco total no Odoo.

Voc√™ est√° 100% certo, e seu hist√≥rico de interesse no Odoo (que eu me lembro) mostra que voc√™ sabe que esta √© uma integra√ß√£o de *alto valor*. O objetivo √© transformar uma conversa de WhatsApp em um **Lead (`crm.lead`)** qualificado dentro do seu CRM, pronto para o seu time de vendas (como o da Embracon) atuar.

Este √© o desenho de engenharia para a **Vers√£o 1.0**, focando *apenas* em adicionar a integra√ß√£o com o Odoo. Vamos pular a parte de IA (WorkersAI) por enquanto, como voc√™ pediu.

A engenharia dessa feature se divide em 4 partes:

1.  **Configura√ß√£o (Frontend/Backend):** Onde o usu√°rio (voc√™) armazena as credenciais do Odoo de forma segura.
2.  **O Editor de Funil (Frontend):** O novo "N√≥" visual (`Enviar para Odoo`) que voc√™ vai arrastar na tela.
3.  **O Motor de Funil (Backend):** A l√≥gica que *executa* a a√ß√£o desse n√≥.
4.  **O Servi√ßo Odoo (Backend):** Um novo m√≥dulo no seu `Backend` que sabe falar a l√≠ngua do Odoo (XML-RPC).

-----

### 1\. ‚öôÔ∏è Configura√ß√£o da Integra√ß√£o (N√≠vel do Workspace)

O usu√°rio n√£o pode digitar a senha do Odoo toda vez. Precisamos de uma tela de "Configura√ß√µes" no seu `Frontend` onde ele salva isso uma √∫nica vez.

#### Novas Telas (Frontend)

  * **Tela: `Configura√ß√µes > Integra√ß√µes`**
      * **Visual:** Uma se√ß√£o "Odoo" com um formul√°rio.
      * **Campos:**
        1.  `URL do Odoo` (ex: `https://meu-odoo.com`)
        2.  `Nome do Banco (DB)` (ex: `embracon_db`)
        3.  `Usu√°rio` (ou `email`)
        4.  `Senha` (ou `API Key`)
      * **Bot√£o:** "Salvar e Testar Conex√£o"

#### Novas Tabelas (PostgreSQL)

Precisamos salvar isso de forma segura. N√£o vamos colocar no `jsonb` do `workspaces`. Vamos criar uma tabela dedicada:

```sql
CREATE TABLE integrations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    platform VARCHAR(50) NOT NULL DEFAULT 'odoo', -- (Pode adicionar 'google_calendar' etc. no futuro)
    
    -- Armazena URL, DB, User. A SENHA N√ÉO VAI AQUI.
    config_data JSONB NOT NULL,
    
    -- Armazena a senha/API key CRIPTOGRAFADA
    -- Voc√™ N√ÉO deve salvar senhas em texto plano.
    encrypted_secret TEXT NOT NULL, 
    
    is_active BOOLEAN DEFAULT true,
    UNIQUE(workspace_id, platform) -- S√≥ pode ter 1 config do Odoo por workspace
);
```

#### Novos Endpoints (API do Backend)

#### `GET /api/v1/integrations/odoo`

  * **O que faz:** Busca a configura√ß√£o *n√£o-sens√≠vel* (URL, DB, User) para preencher o formul√°rio.
  * **Resposta:** `{ "url": "...", "db": "...", "username": "..." }`

#### `POST /api/v1/integrations/odoo`

  * **O que faz:** Salva e testa a configura√ß√£o.
  * **Body (JSON):** `{ "url": "...", "db": "...", "username": "...", "password": "SENHA_AQUI" }`
  * **A√ß√£o do Backend:**
    1.  Recebe os dados.
    2.  Chama o `OdooService` (Parte 4) para tentar autenticar (`check_credentials`).
    3.  Se falhar, retorna Erro 400: "Credenciais inv√°lidas".
    4.  Se sucesso, **CRIPTOgrafa** a senha.
    5.  Salva (ou atualiza) os dados na tabela `integrations`.
    6.  Retorna Sucesso 200: `{ "status": "Conectado com sucesso" }`.

-----

### 2\. ‚úèÔ∏è O Editor de Funil (O "N√≥" do Odoo)

Aqui √© onde voc√™ *usa* a integra√ß√£o. No seu M√≥dulo 5 (Editor de Funil Visual).

#### Novo "N√≥" (Frontend)

  * **Na barra lateral:** Um novo n√≥ arrast√°vel: **"A√ß√£o: Enviar para Odoo"**.

  * **Configura√ß√£o do N√≥ (Painel Lateral):** Quando voc√™ clica no n√≥ no canvas, um painel de configura√ß√£o aparece. Ele precisa fazer o **mapeamento de dados**.

  * **Visual do Painel:**

    > **Criar Lead no Odoo**

    > **Nome do Lead (name):** `[ Campo de Texto ]`
    > **Telefone (phone):** `[ Campo de Texto ]`
    > **Email (email\_from):** `[ Campo de Texto ]`
    > **Descri√ß√£o (description):** `[ √Årea de Texto ]`

  * **Mapeamento com Vari√°veis:** Aqui est√° o pulo do gato. Voc√™ usar√° a sintaxe de vari√°veis do seu funil (como no `n8n`).

      * **Exemplo de preenchimento:**
          * **Nome do Lead:** `Lead do Bot - {{contact.name}}`
          * **Telefone:** `{{contact.phone}}`
          * **Email:** `{{variavel.email_coletado}}` (Uma vari√°vel que voc√™ salvou em um n√≥ `Aguardar Resposta` anterior).
          * **Descri√ß√£o:** `Lead qualificado pelo funil '{{funnel.name}}'.`

#### A Defini√ß√£o do Funil (O JSON Salvo)

Quando o `Frontend` salvar o funil (no `PUT /api/v1/funnels/:id`), o `definition.jsonb` no `PostgreSQL` agora ter√° esse novo tipo de n√≥:

```json
{
  "id": "node_odoo_1",
  "type": "sendToOdoo", 
  "data": {
    "model": "crm.lead", // Fixo por enquanto
    "mapping": {
      "name": "Lead do Bot - {{contact.name}}",
      "phone": "{{contact.phone}}",
      "email_from": "{{variavel.email_coletado}}",
      "description": "Lead qualificado..."
    }
  },
  "position": { ... }
}
```

-----

### 3\. üß† O Motor de Funil (Execu√ß√£o no Backend)

Esta √© a l√≥gica do "Motor" (que detalhamos no MVP 2) sendo *atualizada*.

1.  O Motor de Funil est√° executando um funil para o `contact_uuid_1`.
2.  Ele chega no n√≥ `node_odoo_1` (tipo: `sendToOdoo`).
3.  **A√ß√£o do Motor:**
    a.  **Resolver Vari√°veis:** Pega o `data.mapping` do n√≥. Ele consulta o estado do Redis (para `{{variavel.email_coletado}}`) e o `PostgreSQL` (para `{{contact.name}}` e `{{contact.phone}}`) e monta o objeto `leadData` final:
    ` json { "name": "Lead do Bot - Alan Evangelista", "phone": "554199998888", "email_from": "alan@embracon.com.br", "description": "Lead qualificado..." }  `
    b.  **Buscar Credenciais:** Consulta a tabela `integrations` pelo `workspace_id` atual. Pega a URL, DB, User e **descriptografa** a `encrypted_secret`.
    c.  **Chamar o Servi√ßo:** Chama o `OdooService` (Parte 4) e passa as credenciais e o `leadData`.
    d.  **Processar Resultado:**
    \* **Sucesso:** O `OdooService` retorna `{ "ok": true, "lead_id": 12345 }`. O Motor de Funil segue para o pr√≥ximo n√≥ (ex: um n√≥ `Enviar Mensagem` que diz "Pronto\! Seu agendamento foi iniciado.").
    \* **Falha:** O `OdooService` retorna um erro. O Motor deve ter uma sa√≠da de "Falha" no n√≥, para que voc√™ possa, por exemplo, enviar uma notifica√ß√£o para um humano intervir.

-----

### 4\. üìû O Servi√ßo Odoo (O Conector Externo no Backend)

Este √© um *novo* m√≥dulo de c√≥digo dentro do seu `Backend` (ex: `src/services/odoo.service.ts`). Ele √© o √∫nico que sabe como "falar" com o Odoo.

**Importante:** A API principal do Odoo (para `crm.lead`) **n√£o √© REST/JSON**. √â **XML-RPC**. Voc√™ *precisa* de uma biblioteca para lidar com isso. Em Node.js, uma biblioteca como `odoo-await` ou `json-rpc` √© ideal.

```typescript
// Exemplo de c√≥digo (simplificado) para o seu odoo.service.ts

import Odoo from 'odoo-await'; // Exemplo de biblioteca

export class OdooService {
  
  async checkCredentials(config) {
    const odoo = new Odoo(config);
    await odoo.connect();
    return true; // Se n√£o deu erro, conectou.
  }

  async createLead(config, leadData) {
    // config = { url, db, username, password }
    // leadData = { name, phone, ... }
    
    try {
      const odoo = new Odoo(config);
      await odoo.connect();
      
      // Odoo espera 'create(model_name, data_object)'
      const leadId = await odoo.create('crm.lead', leadData);
      
      if (!leadId) {
        throw new Error('Odoo n√£o retornou um ID.');
      }
      
      return { ok: true, lead_id: leadId };
      
    } catch (error) {
      console.error('Falha ao criar Lead no Odoo:', error.message);
      throw new Error(`Erro de comunica√ß√£o com Odoo: ${error.message}`);
    }
  }
}
```

### Resumo do Desenho V1.0 (Odoo)

Com essas 4 partes, voc√™ tem um sistema profissional:

1.  O `Frontend` tem uma tela para **salvar as credenciais** (criptografadas no DB).
2.  O `Frontend` permite ao usu√°rio **mapear vari√°veis** do bot para os campos do Odoo (`crm.lead`).
3.  O `Backend` (Motor) **orquestra** a opera√ß√£o: pega os dados, pega as chaves, e chama o servi√ßo.
4.  O `Backend` (Servi√ßo) **isola** a l√≥gica complexa (XML-RPC) de comunica√ß√£o com o Odoo.

Isso completa o fluxo principal que voc√™ queria: **WhatsApp -\> Bot (Qualifica√ß√£o) -\> Odoo (CRM)**.

O pr√≥ximo passo l√≥gico seria adicionar os outros itens da V1.0 que mencionamos, como o **M√≥dulo 2 (Gest√£o de Equipe/Atendentes)** e o roteamento de chats. Quer detalhar esse?

Claro. Este √© o detalhe de engenharia do **M√≥dulo 2 (Gest√£o de Equipe e Atendentes)** e sua principal funcionalidade: o **Roteamento de Chats**.

Este m√≥dulo √© o que transforma sua ferramenta de "um bot" para uma "plataforma de atendimento" (como o ManyChat ou 3C+). Ele permite que m√∫ltiplos humanos colaborem.

A engenharia se divide em 4 partes:

1.  **Novas Estruturas de Dados (PostgreSQL):** Como armazenamos "times" e o "estado" de um chat.
2.  **Telas de Configura√ß√£o (Frontend):** Onde o "Admin" gerencia a equipe.
3.  **Endpoints da API (Backend):** O que o Frontend chama para salvar essas configura√ß√µes.
4.  **L√≥gica de Roteamento (O "Upgrade" Cr√≠tico):** Como o Bot (M√≥dulo 5) e a Caixa de Entrada (M√≥dulo 4) *usam* essa estrutura de equipes.

-----

### 1\. üèõÔ∏è Desenho de Dados (Refinando o PostgreSQL)

Para o roteamento funcionar, n√£o basta saber *quem* s√£o os contatos, precisamos saber o *estado* da conversa com eles. Para isso, introduzimos duas novas tabelas cruciais:

#### `teams` (Os departamentos/esquadr√µes)

Define os grupos de atendimento (ex: "Vendas", "Suporte").

```sql
CREATE TABLE teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    UNIQUE(workspace_id, name)
);
```

#### `team_members` (Piv√¥: Quem est√° em qual time)

Um agente (`user`) pode estar em m√∫ltiplos times.

```sql
CREATE TABLE team_members (
    -- Usamos workspace_member_id para garantir que o usu√°rio pertence ao workspace
    member_id UUID NOT NULL REFERENCES workspace_members(id) ON DELETE CASCADE, 
    team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    PRIMARY KEY (member_id, team_id)
);

-- (Nota: A tabela 'workspace_members' que j√° definimos √© a que liga 'users' a 'workspaces' e define seu 'role' (admin/agent))
```

#### `conversations` (O "Estado" do Chat) - A TABELA MAIS IMPORTANTE

Esta √© a maior mudan√ßa. A "Caixa de Entrada" (M√≥dulo 4) n√£o ser√° mais uma lista de `contacts`; ser√° uma lista de `conversations`. Isso nos permite rastrear *a quem* o chat pertence.

```sql
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    instance_id UUID NOT NULL REFERENCES instances(id) ON DELETE CASCADE,
    
    -- O ESTADO DO CHAT
    status VARCHAR(20) NOT NULL DEFAULT 'open', -- 'open', 'pending', 'closed'
    
    -- O ROTEAMENTO (quem √© o dono)
    team_id UUID REFERENCES teams(id),         -- NULO = N√£o atribu√≠do (cai na fila geral)
    agent_id UUID REFERENCES users(id),        -- NULO = N√£o atribu√≠do a um agente espec√≠fico
    
    -- Para ordena√ß√£o
    last_message_at TIMESTAMPTZ DEFAULT now(),
    
    UNIQUE(contact_id, instance_id) -- S√≥ pode ter 1 conversa aberta por contato/inst√¢ncia
);
```

**A√ß√£o de Engenharia:** Quando uma *nova mensagem* (Fluxo RX) de um *novo contato* chegar, o `Backend` deve, al√©m de salvar na tabela `messages`, **criar** um novo registro na tabela `conversations`.

-----

### 2\. üíª Telas de Configura√ß√£o (Frontend - M√≥dulo 2)

O Admin do `workspace` (definido pelo `role` 'admin' na tabela `workspace_members`) ver√° um novo item no menu:

  * **Tela: `Configura√ß√µes > Equipe`**
      * **Tab 1: "Membros"**
          * **Visual:** Uma lista de todos os `workspace_members`.
          * **Fun√ß√µes:**
              * Bot√£o "Convidar Membro" (input de email).
              * Para cada membro: Dropdown `Fun√ß√£o` ("Admin" ou "Agente").
              * Para cada membro: Seletor de `Times` (mostra as `teams` da Tab 2).
      * **Tab 2: "Times"**
          * **Visual:** Uma lista de `teams` criados.
          * **Fun√ß√µes:**
              * Bot√£o "Criar Time" (input de nome).
              * Clicar em um time permite adicionar/remover membros (que v√™m da Tab 1).

-----

### 3\. üì° Endpoints da API (Backend - M√≥dulo 2)

Como o `Frontend` (acima) salva os dados no `Backend`.

#### `GET /api/v1/team/members`

  * **O que faz:** Lista todos os membros do workspace (para a Tab 1).
  * **Resposta:** `[ { userId, name, email, role, teams: [ { teamId, teamName }, ... ] }, ... ]`

#### `POST /api/v1/team/invite`

  * **O que faz:** Convida um novo usu√°rio (atendente) para o workspace.
  * **Body (JSON):** `{ "email": "...", "role": "agent" }`
  * **A√ß√£o do Backend:** Envia um e-mail de convite para o usu√°rio se cadastrar.

#### `PUT /api/v1/team/members/:userId`

  * **O que faz:** Atualiza a `role` ou os `teams` de um membro.
  * **Body (JSON):** `{ "role": "admin", "teamIds": ["uuid_time_vendas", ...] }`

#### `GET /api/v1/team/teams`

  * **O que faz:** Lista todos os times criados (para a Tab 2 e para os dropdowns de roteamento).

#### `POST /api/v1/team/teams`

  * **O que faz:** Cria um novo time.
  * **Body (JSON):** `{ "name": "Suporte N√≠vel 2" }`

-----

### 4\. üöÄ L√≥gica de Roteamento (A Funcionalidade)

Agora que temos `teams` e `conversations`, vamos us√°-los em dois lugares:

#### A) Roteamento Autom√°tico (No Editor de Funil - M√≥dulo 5)

  * **Novo "N√≥" no Editor Visual:**

      * **Nome:** `A√ß√£o: Rotear Conversa`
      * **Configura√ß√£o do N√≥ (Painel Lateral):**
          * Dropdown "Atribuir para...":
              * Op√ß√£o 1: "Um Time" -\> (Dropdown com lista de `teams`)
              * Op√ß√£o 2: "Um Agente" -\> (Dropdown com lista de `agents`)
          * Checkbox: "[‚úì] Pausar bot ao atribuir" (Isso seta o `bot_control` no Redis).

  * **A√ß√£o do Backend (Motor de Funil):**

    1.  Quando o Motor de Funil (MVP 2) chega neste n√≥...
    2.  Ele l√™ a configura√ß√£o (ex: "atribuir para `team_vendas_id`").
    3.  Ele executa no `PostgreSQL`: `UPDATE conversations SET team_id = 'team_vendas_id' WHERE contact_id = 'contact_abc' AND status = 'open'`.
    4.  Se o checkbox "Pausar bot" estiver marcado, ele tamb√©m executa no **Redis**: `SET bot_control:554199998888 "PAUSED_BY_BOT"`.

#### B) Roteamento Manual (Na Caixa de Entrada - M√≥dulo 4)

  * **"Upgrade" da Caixa de Entrada:**

      * **Coluna 1 (Lista de Chats):** Agora √© uma lista de `conversations` (n√£o `contacts`). Ela ter√° filtros: "Minhas", "Time Vendas", "N√£o Atribu√≠das".
      * **Coluna 3 (Dados do Chat):** Agora exibe:
          * `Atribu√≠do a (Time): [ Dropdown de Times ]`
          * `Atribu√≠do a (Agente): [ Dropdown de Agentes ]`
          * `Status: [ Dropdown 'Aberto', 'Pendente', 'Fechado' ]`

  * **Novos Endpoints da API (M√≥dulo 4):**

    #### `GET /api/v1/chats` (Endpoint Atualizado)

      * **O que faz:** Busca as conversas para a Caixa de Entrada.
      * **Query Params:** `?status=open&teamId=...&agentId=me`
      * **A√ß√£o do Backend:** Faz um `SELECT * FROM conversations JOIN contacts ...` com os filtros.

    #### `PUT /api/v1/chats/:conversationId/assign`

      * **O que faz:** Quando o humano muda o dropdown de atribui√ß√£o.
      * **Body (JSON):** `{ "teamId": "team_vendas_id" }` (ou `{ "agentId": "agent_xyz_id" }`)
      * **A√ß√£o do Backend:** Faz o `UPDATE` na tabela `conversations`.

    #### `PUT /api/v1/chats/:conversationId/status`

      * **O que faz:** Quando o humano fecha a conversa.
      * **Body (JSON):** `{ "status": "closed" }`

### Resumo do Desenho V1.0 (Equipes + Odoo)

Com o detalhamento do **M√≥dulo Odoo** (anterior) e este **M√≥dulo de Equipes**, sua V1.0 est√° completa. Voc√™ ter√° um sistema onde:

1.  M√∫ltiplos agentes podem logar.
2.  Admins podem criar Times (Vendas, Suporte).
3.  O Bot (Funil) pode **qualificar** um lead e **rote√°-lo** automaticamente para o "Time de Vendas".
4.  O Bot (Funil) pode **pausar-se** sozinho ap√≥s o roteamento.
5.  O Bot (Funil) pode enviar o lead qualificado para o **Odoo**.
6.  Um agente do Time de Vendas v√™ o chat "N√£o Atribu√≠do" na sua fila, pega a conversa e finaliza o agendamento manualmente na `Caixa de Entrada`.

O pr√≥ximo passo l√≥gico seria detalhar a engenharia dos **"N√≥s Inteligentes" (IA com WorkersAI)**, que √© o M√≥dulo 5 completo, ou detalhar o **M√≥dulo de Contatos (CRM Interno)**. Qual prefere?

Entendido, meu amigo. Voc√™ captou perfeitamente. O WorkersAI n√£o √© o produto, √© o *motor* de intelig√™ncia, assim como o modelo da OpenAI √© o motor do ManyChat.

O **M√≥dulo de Contatos (CRM Interno)** √© onde o valor do seu neg√≥cio (e do seu time de vendas, como o da Embracon) realmente aparece. N√£o √© s√≥ uma lista de telefones; √© o *dossi√™ completo* de cada lead.

No MVP 2, criamos as tabelas `contacts` e `tags`. Agora, vamos construir as **telas e a l√≥gica de neg√≥cios** em cima delas, transformando-as em um CRM de verdade. E vamos injetar a IA (WorkersAI) onde ela gera mais impacto.

Este √© o desenho de engenharia do "M√≥dulo de Contatos" (V1.0).

-----

### 1\. üó∫Ô∏è A Vis√£o: "Tela de Contatos" vs. "Vis√£o 360"

Seu CRM Interno ter√° duas telas principais:

1.  **A Lista (`/contacts`):** O "Dashboard de Contatos". Uma vis√£o de alto n√≠vel, tipo planilha, para gerentes e para segmenta√ß√£o em massa.
2.  **O Detalhe (`/contacts/:id`):** A "Vis√£o 360 do Contato". Esta √© a tela mais importante do seu sistema para um atendente. √â onde ele v√™ *tudo* sobre *um* lead.

-----

### 2\. üíª Tela 1: O Dashboard de Contatos (A Lista)

Esta √© a tela principal do M√≥dulo 3.

  * **Visual:** Uma tabela densa e poderosa (pense em um "Google Analytics" de leads).
  * **Colunas:** `[Checkbox]`, `Nome`, `Telefone`, `Tags`, `Atendente Respons√°vel`, `Time`, `√öltima Mensagem`.
  * **Funcionalidades de Engenharia (Filtros):** O `Frontend` deve ter filtros que, no `Backend`, se traduzem em queries SQL complexas (com `JOIN`s).
      * **Filtro por `Tags`:** (Ex: "s√≥ leads com a tag 'aguardando\_agendamento'").
      * **Filtro por `Atendente`:** (Ex: "s√≥ leads do `agent_id` = 'alan\_uuid'"). (JOIN com `conversations`).
      * **Filtro por `Time`:** (Ex: "s√≥ leads do `team_id` = 'vendas\_uuid'"). (JOIN com `conversations`).
      * **Filtro por `Campo Personalizado`:** (Ex: "s√≥ leads onde `custom_data.cidade` = 'Fazenda Rio Grande'"). (Query no `jsonb`).
  * **Funcionalidade (A√ß√£o em Massa):**
      * O usu√°rio seleciona 20 checkboxes.
      * Clica em "A√ß√µes" -\> "Adicionar Tag".
      * O `Frontend` chama um novo endpoint: `POST /api/v1/contacts/bulk/tags`.

-----

### 3\. üñ•Ô∏è Tela 2: A "Vis√£o 360" do Contato (O Dossi√™)

Esta √© a tela de detalhe (`/contacts/:id`). √â aqui que o WorkersAI brilha. O layout ideal √© de 3 colunas.

#### Coluna 1: Dados do Lead (O "Quem")

  * **Visual:** Campos de formul√°rio (edit√°veis).
  * **Campos Fixos:**
      * `Nome` (da `contacts.name`)
      * `Telefone` (da `contacts.phone_number`)
  * **Campos de Propriedade (Atribui√ß√£o):**
      * `Atendente:` [Dropdown com `users` da `conversations.agent_id`]
      * `Time:` [Dropdown com `teams` da `conversations.team_id`]
  * **Campos Personalizados (CRM):**
      * Estes campos s√£o lidos e escritos da coluna `contacts.custom_data` (o `jsonb`).
      * `Email:` [Campo de texto]
      * `Cidade:` [Campo de texto]
      * `Fase do Funil:` [Dropdown] (Ex: "Qualifica√ß√£o", "Agendamento", "Fechado")

#### Coluna 2: Feed de Atividades (O "Hist√≥rico Completo")

Esta √© a *killer feature*. N√£o √© s√≥ o chat. √â um feed *cronol√≥gico intercalado* de **tudo** o que aconteceu com esse lead.

  * **Visual:** Um feed do Facebook/LinkedIn.
  * **Itens do Feed (Agregados de 3 tabelas):**
      * **Mensagem (IN/OUT):** (Da tabela `messages`) "Alan (Lead) disse: 'qual o pre√ßo?'".
      * **A√ß√£o do Bot:** (Log do Motor de Funil) "Bot adicionou a tag 'lead\_quente'".
      * **A√ß√£o do Agente:** (Log do Backend) "J√∫nior (Agente) atribuiu este lead ao Time de Vendas".
      * **Nota Interna:** (Nova tabela) "J√∫nior (Agente) escreveu: 'Lead parece muito interessado, ligar amanh√£ √†s 10h.'".

#### Coluna 3: Intelig√™ncia (O "Upgrade" WorkersAI)

Esta coluna √© o "c√©rebro" que ajuda o atendente.

  * **Widget 1: Resumo da IA (WorkersAI)**
      * **Visual:** Um card no topo.
      * **Texto:** "Resumo: Alan Evangelista √© um lead qualificado, interessado no produto X. Ele j√° forneceu o email e est√° aguardando op√ß√µes de hor√°rio para agendamento. O sentimento √© positivo."
  * **Widget 2: Tags (Segmenta√ß√£o)**
      * **Visual:** Lista de tags (da tabela `contact_tags`).
      * **Fun√ß√£o:** Adicionar/Remover tags.
  * **Widget 3: Pr√≥xima A√ß√£o (IA Sugerida)**
      * **Visual:** Um bot√£o ou sugest√£o.
      * **Texto:** "Sugest√£o: Enviar link do Calendly."

-----

### 4\. üß† A Engenharia da IA (WorkersAI) no CRM

Como o WorkersAI alimenta a Coluna 1 e a Coluna 3? Com **processamento ass√≠ncrono**.

#### Feature A: Extra√ß√£o de Dados (Preenchimento Autom√°tico)

  * **Objetivo:** Quando o lead diz "meu email √© alan@embracon.com.br", o campo `Email` na Coluna 1 deve ser preenchido *sozinho*.
  * **Desenho de Engenharia:**
    1.  A Mensagem `IN` chega no `Backend` (Fluxo RX, MVP 1).
    2.  O `Backend` a salva no `PostgreSQL`.
    3.  O `Backend` a envia para o `Motor de Funil` (MVP 2).
    4.  **NOVO PASSO:** O `Backend` *tamb√©m* publica a mensagem em uma *nova* fila do RabbitMQ: `queue-ai-extraction`.
    5.  Um *novo servi√ßo* (vamos cham√°-lo de `IA-Worker`) est√° consumindo essa fila.
    6.  O `IA-Worker` pega a mensagem (`contact_id` e o texto).
    7.  Ele chama o **WorkersAI** (Cloudflare) com um prompt: "Voc√™ √© um extrator de dados. Encontre 'email', 'nome', 'cidade' no texto a seguir e retorne um JSON. Texto: '...'".
    8.  O WorkersAI retorna: `{ "email": "alan@embracon.com.br" }`.
    9.  O `IA-Worker` executa no `PostgreSQL`: `UPDATE contacts SET custom_data = custom_data || '{"email": "alan@embracon.com.br"}' WHERE id = 'contact_uuid_1'`.
    10. **M√°gica:** O atendente humano, que est√° com a "Vis√£o 360" aberta, v√™ o campo `Email` ser preenchido em tempo real (via um evento WebSocket `contact:updated`).

#### Feature B: Resumo da Conversa (Sob Demanda)

  * **Objetivo:** Gerar o "Resumo da IA" na Coluna 3.
  * **Desenho de Engenharia:**
    1.  O atendente abre a tela `/contacts/:id` (Vis√£o 360).
    2.  O `Frontend` chama um *novo endpoint*: `GET /api/v1/contacts/:id/summary`.
    3.  O `Backend` busca as √∫ltimas 50 `messages` desse contato no `PostgreSQL`.
    4.  Ele formata o hist√≥rico: `Lead: 'oi', Bot: 'tudo bem', Lead: 'sim, quero pre√ßo'...`
    5.  Ele chama o **WorkersAI** com um prompt: "Resuma esta conversa de vendas em 2 frases."
    6.  O `Backend` retorna o texto do resumo para o `Frontend` exibir.

-----

### 5\. üì° Endpoints de API (O "Desenho" do M√≥dulo 3)

Como o `Frontend` constr√≥i essas telas.

#### `GET /api/v1/contacts` (Endpoint Atualizado)

  * **O que faz:** Lista os contatos para o "Dashboard" (Tela 1).
  * **Query Params (Filtros):** `?tag=uuid&agent=uuid&team=uuid&search=alan`
  * **Resposta:** (Array de `contacts` com `JOIN`s para `tags` e `conversations`).

#### `POST /api/v1/contacts/bulk/tags` (Novo)

  * **O que faz:** Adiciona/remove tags em massa (A√ß√£o da Tela 1).
  * **Body (JSON):** `{ "contactIds": ["uuid1", "uuid2"], "addTagIds": ["tag_abc"], "removeTagIds": [] }`

#### `GET /api/v1/contacts/:id` (Endpoint Atualizado)

  * **O que faz:** Carrega *todos* os dados da "Vis√£o 360" (Tela 2, Coluna 1 e 3).
  * **Resposta:** Um JSON gigante agregado de 3 tabelas.
    ```json
    {
      "id": "contact_uuid_1",
      "name": "Alan Evangelista",
      "phone_number": "...",
      "custom_data": { "email": "alan@embracon.com.br" },
      "tags": [ { "id": "tag_abc", "name": "Lead Quente" } ],
      "assignment": { // Da tabela 'conversations'
        "agent": { "id": "agent_uuid_junior", "name": "J√∫nior" },
        "team": { "id": "team_uuid_vendas", "name": "Vendas" }
      }
    }
    ```

#### `GET /api/v1/contacts/:id/activity_feed` (Novo)

  * **O que faz:** Carrega *apenas* o "Feed de Atividades" (Tela 2, Coluna 2). (√â separado para pagina√ß√£o, pois pode ser enorme).
  * **Query Params:** `?page=1&limit=20`
  * **Resposta:** (Array de `messages` e `notes` intercalados e ordenados por data).

#### `POST /api/v1/contacts/:id/notes` (Novo)

  * **O que faz:** Permite a um agente adicionar uma nota interna no feed.
  * **Body (JSON):** `{ "text": "Ligar para este cliente amanh√£." }`

#### `GET /api/v1/contacts/:id/summary` (Novo)

  * **O que faz:** Chama a Feature B (Resumo da IA) sob demanda.
  * **Resposta:** `{ "summary": "Este lead est√° qualificado..." }`

Com este m√≥dulo, seu sistema deixa de ser um "disparador de bot" e se torna um "centro de comando de vendas", que √© exatamente o que um l√≠der de equipe precisa.

O pr√≥ximo passo l√≥gico seria detalhar o **M√≥dulo 5 completo**, focando no **N√≥ de IA (WorkersAI)** dentro do *pr√≥prio funil* (que √© diferente do uso da IA no CRM). Quer explorar isso?

Certo, meu amigo. Chegamos ao *cora√ß√£o* da sua plataforma.

At√© agora, t√≠nhamos um bot "burro" (MVP 2), que s√≥ entendia `IF/THEN` (se a pessoa digitar "sim", fa√ßa X). Agora, vamos detalhar a engenharia para dar a ele um c√©rebro (o **WorkersAI**), permitindo que ele *entenda* linguagem natural e execute seu objetivo principal: **qualificar e agendar uma reuni√£o**.

O **M√≥dulo de Contatos (CRM Interno)** que detalhamos antes usava a IA de forma *passiva* (para resumir e extrair dados *depois* que a conversa aconteceu).

Este **M√≥dulo 5 (N√≥ de IA)** usa a IA de forma *ativa*, para **decidir o que dizer a seguir** em tempo real.

Aqui est√° o desenho de engenharia completo.

-----

### 1\. Frontend: O Novo "N√≥ de IA" no Editor de Funil

No seu M√≥dulo 5 (Editor de Funil Visual, como o `n8n`), voc√™ ter√° um novo n√≥ arrast√°vel na barra lateral.

  * **Nome do N√≥:** `üß† Gerar Resposta com IA` (ou `Resposta Inteligente`)

Quando voc√™ (Alan) arrastar este n√≥ para o canvas e clicar nele, o painel de configura√ß√£o √† direita n√£o ser√° um `IF/THEN` simples. Ele ter√° duas se√ß√µes principais:

#### A. O "Prompt" (O C√©rebro)

Esta √© a instru√ß√£o que voc√™ d√° ao WorkersAI. √â a parte mais importante.

  * **Visual:** Uma caixa de texto grande.
  * **Funcionalidade:** Ela deve aceitar **vari√°veis** do seu sistema.
  * **Exemplo de Prompt para Agendamento:**
    > Voc√™ √© um assistente de vendas da Embracon. Seu √∫nico objetivo √© qualificar um lead para agendar uma reuni√£o com um vendedor humano.
    > **Dados que voc√™ j√° tem (se tiver):**
    > Nome do Lead: `{{contact.name}}`
    > Email: `{{contact.custom_data.email}}`
    > **Hist√≥rico Recente:**
    > `{{chat.history_last_3_messages}}`
    > **√öltima Mensagem do Usu√°rio:**
    > `{{trigger.message}}`
    > **Sua Tarefa:**
    > 1.  Analise a "√öltima Mensagem do Usu√°rio".
    > 2.  Se voc√™ ainda n√£o tem o NOME, pe√ßa o nome.
    > 3.  Se voc√™ j√° tem o NOME mas n√£o o EMAIL, pe√ßa o email.
    > 4.  Se voc√™ j√° tem NOME e EMAIL, pergunte o melhor hor√°rio para a reuni√£o.
    > 5.  Responda de forma natural, em portugu√™s.

#### B. Extra√ß√£o de Dados (A "Fun√ß√£o" da IA)

Voc√™ n√£o quer que a IA apenas *fale*, voc√™ quer que ela *aja*. Para isso, usamos a funcionalidade de "Tools" (ou "Function Calling") que modelos como o do WorkersAI suportam.

  * **Visual:** Uma se√ß√£o "Dados a Extrair".
  * **Fun√ß√£o:** Voc√™ define um "schema" do que voc√™ quer que a IA capture da resposta do usu√°rio.
  * **Exemplo de Configura√ß√£o:**
      * `[Checkbox] Extrair dados da resposta do usu√°rio`
      * **Schema (Formato JSON):**
        ```json
        {
          "name": "nome_do_lead",
          "email": "email_do_lead",
          "horario": "horario_preferido"
        }
        ```
  * **A√ß√£o (Onde Salvar):**
      * `[Checkbox] Salvar dados extra√≠dos nos Campos Personalizados do Contato` (Isso atualiza o `contacts.custom_data` no PostgreSQL).

-----

### 2\. Backend: O JSON Salvo (`funnels.definition`)

Quando voc√™ salva esse funil, o `jsonb` no seu `PostgreSQL` para este n√≥ se parecer√° com isto:

```json
{
  "id": "node_ai_qualify_1",
  "type": "aiGenerate", // O tipo de n√≥
  "data": {
    "prompt": "Voc√™ √© um assistente da Embracon... {{trigger.message}} ...", // O prompt que voc√™ escreveu
    "extraction_schema": { // O 'schema' de extra√ß√£o
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "email": { "type": "string" },
        "horario": { "type": "string" }
      }
    },
    "save_to_contact": true, // O checkbox "Salvar dados..."
    "outputs": {
      "on_success": "..." // O conector de sa√≠da "Sucesso"
    }
  },
  "position": { "x": 100, "y": 200 }
}
```

-----

### 3\. Backend: A Execu√ß√£o no "Motor de Funil"

Este √© o desenho de engenharia de *execu√ß√£o*. √â o que acontece no seu `Backend` (Servi√ßo) quando o funil chega neste n√≥.

1.  O `Motor de Funil` (MVP 2) est√° executando o funil para o `contact_id: 'alan_uuid'`.
2.  Ele chega no n√≥ `node_ai_qualify_1` (tipo `aiGenerate`).

#### Passo 1: Resolu√ß√£o de Vari√°veis (O "Prompt")

O Motor *monta* o prompt. Ele busca no `PostgreSQL` e `Redis` todos os valores das vari√°veis:

  * `{{contact.name}}` -\> "Alan Evangelista"
  * `{{contact.custom_data.email}}` -\> `null` (ainda n√£o tem)
  * `{{trigger.message}}` -\> "opa, tenho interesse em saber mais"
  * O prompt final √© montado e est√° pronto para ser enviado.

#### Passo 2: A Chamada para o WorkersAI (A Intelig√™ncia)

O `Backend` *n√£o* faz uma chamada simples de "texto entra, texto sai". Ele faz uma chamada sofisticada usando as `tools` que voc√™ definiu no `extraction_schema`.

**A√ß√£o:** Seu `Backend` faz um `fetch` para a API do Cloudflare WorkersAI.

**Payload (O que voc√™ envia para a IA):**

```json
{
  "model": "@cf/meta/llama-3-8b-instruct", // (Ou outro modelo que suporte 'tools')
  "prompt": "Voc√™ √© um assistente da Embracon... √öltima Mensagem: 'opa, tenho interesse em saber mais' ...",
  "tools": [ // Aqui est√° a m√°gica
    {
      "name": "salvar_dados_lead",
      "description": "Use esta fun√ß√£o para salvar ou atualizar os dados do lead.",
      "parameters": { // O 'extraction_schema' que voc√™ definiu
        "type": "object",
        "properties": {
          "name": { "type": "string" },
          "email": { "type": "string" },
          "horario": { "type": "string" }
        }
      }
    }
  ]
}
```

#### Passo 3: Processamento da Resposta (A L√≥gica)

O `Backend` recebe a resposta do WorkersAI. Essa resposta pode ter duas formas:

**Caso A: A IA responde com Texto**

  * **O que acontece:** O usu√°rio disse "tenho interesse" e o prompt mandou a IA "pedir o nome". A IA decide que n√£o precisa extrair nada, apenas *falar*.
  * **Resposta da IA (JSON):**
    ```json
    { "response": "Que √≥timo! Para come√ßar, pode me dizer seu nome completo, por favor?" }
    ```
  * **A√ß√£o do Motor de Funil:**
    1.  Pega o texto `"Que √≥timo! ... por favor?"`.
    2.  Publica este texto na `exchange-tx-outgoing` (RabbitMQ) para ser enviado ao usu√°rio.
    3.  Segue para o pr√≥ximo n√≥ no funil (que √©, provavelmente, um `N√≥: Aguardar Resposta`).

**Caso B: A IA responde com Texto E Extra√ß√£o de Dados (O mais comum)**

  * **O que acontece:** O Motor de Funil est√° no Passo 3 (pedir e-mail). A √∫ltima mensagem do usu√°rio foi: "Meu e-mail √© alan@embracon.com.br".
  * **Resposta da IA (JSON):**
    ```json
    {
      "tool_calls": [ // A IA detectou dados!
        {
          "name": "salvar_dados_lead",
          "arguments": {
            "email": "alan@embracon.com.br" 
          }
        }
      ],
      "response": "Perfeito, e-mail anotado! E qual o melhor dia e hor√°rio para um de nossos especialistas falar com voc√™?" // A IA j√° fez a pr√≥xima pergunta!
    }
    ```
  * **A√ß√£o do Motor de Funil (Dupla A√ß√£o):**
    1.  **A√ß√£o 1 (Dados):** O Motor v√™ o `tool_calls`. Ele pega `{"email": "alan@embracon.com.br"}`. Se `save_to_contact` for `true`, ele executa imediatamente: `UPDATE contacts SET custom_data = custom_data || '{"email": "alan@..."}' WHERE id = 'alan_uuid'`.
    2.  **A√ß√£o 2 (Mensagem):** O Motor pega o `"response": "Perfeito, e-mail anotado! ..."`.
    3.  Publica este texto na `exchange-tx-outgoing` (RabbitMQ) para ser enviado ao usu√°rio.
    4.  Segue para o pr√≥ximo n√≥ (que √©, provavelmente, `N√≥: Aguardar Resposta`).

### Resumo do Desenho (V1.0 - IA Ativa)

Com este n√≥, seu funil de "bot burro" se transforma em:

**Funil de Agendamento Inteligente:**

1.  **Gatilho:** `Keyword: "vendas"`
2.  **N√≥:** `Gerar Resposta IA`
      * **Prompt:** "Apresente-se e pe√ßa o nome."
3.  **N√≥:** `Aguardar Resposta`
4.  **N√≥:** `Gerar Resposta IA` (Aqui o `{{trigger.message}}` cont√©m o nome do usu√°rio)
      * **Prompt:** "Obrigado `{{contact.name}}`. Agora pe√ßa o e-mail."
      * **Extra√ß√£o:** `{"email": "..."}`
5.  **N√≥:** `Aguardar Resposta`
6.  **N√≥:** `Gerar Resposta IA` (Aqui o `{{trigger.message}}` cont√©m o e-mail, e a IA no passo anterior *j√° salvou* o e-mail no banco)
      * **Prompt:** "Perfeito. Agora pe√ßa o melhor hor√°rio."
      * **Extra√ß√£o:** `{"horario": "..."}`
7.  **N√≥:** `Aguardar Resposta`
8.  **N√≥:** `Enviar para Odoo` (M√≥dulo que j√° detalhamos)
      * **Mapping:** `name: {{contact.name}}`, `email: {{contact.custom_data.email}}`, `description: "Agendar em: {{contact.custom_data.horario}}"`
9.  **N√≥:** `Rotear Conversa` (M√≥dulo que j√° detalhamos)
      * **A√ß√£o:** Atribuir ao "Time de Vendas" e Pausar o Bot.
10. **N√≥:** `Enviar Mensagem` (Simples)
      * **Texto:** "Tudo certo\! Um de nossos especialistas j√° vai te chamar para confirmar o agendamento."

Este √© o fluxo de engenharia completo para uma automa√ß√£o de ponta-a-ponta.

O pr√≥ximo passo l√≥gico seria detalhar o **M√≥dulo de Disparo de Mensagens** (Campanhas Ativas / Bulk Messaging) ou o **M√≥dulo de Dashboards/Analytics**. Qual deles voc√™ prefere?

Entendido, meu amigo. Foco total no receptivo.

Faz todo o sentido. Para um pipeline de qualifica√ß√£o de vendas, a prioridade √© gerenciar o fluxo que *chega*. Al√©m disso, usar a API n√£o-oficial para disparo em massa (campanhas) √© o caminho mais r√°pido para ter o n√∫mero banido. Manter-se receptivo √© a estrat√©gia mais segura e de maior valor.

Sendo assim, o pr√≥ximo passo l√≥gico √© o **M√≥dulo de Dashboards e Analytics**.

Se voc√™ n√£o pode medir, voc√™ n√£o pode gerenciar. Para um l√≠der de vendas, saber os n√∫meros √© o que separa uma "ferramenta" de uma "solu√ß√£o de neg√≥cios". Voc√™ precisa saber se o seu funil de IA e seus atendentes est√£o performando.

Este m√≥dulo n√£o √© apenas uma tela; √© um conjunto de *endpoints* de agrega√ß√£o no seu `Backend` que faz consultas complexas (contagens, m√©dias, agrupamentos) no seu banco `PostgreSQL`.

Vamos detalhar o desenho de engenharia para os 3 dashboards essenciais.

-----

### 1\. üìä Dashboard 1: Vis√£o Geral (O "Pulso" do Neg√≥cio)

Esta √© a tela principal (`/dashboard`) que o administrador (voc√™) v√™ ao logar. Ela responde: **"Como estamos hoje?"**

#### O que o Frontend exibe (KPIs):

  * **Cards (KPIs Principais):**

      * **Novas Conversas (√öltimos 7 dias):** `[N√∫mero]`
      * **Total de Leads Qualificados (IA):** `[N√∫mero]` (Ex: Leads que receberam a tag 'ia\_qualificado')
      * **Leads Enviados ao Odoo (Total):** `[N√∫mero]`
      * **Conversas Abertas (Agora):** `[N√∫mero]`
      * **Tempo M√©dio de Atendimento (TMA):** `[Minutos/Horas]`

  * **Gr√°ficos:**

      * **Gr√°fico de Funil (Convers√£o Total):**
        1.  `Novas Conversas` (Total que iniciou chat)
        2.  `Leads Qualificados (IA)` (Total que o bot marcou como 'qualificado')
        3.  `Enviados ao Odoo` (Total que o n√≥ do Odoo executou com sucesso)
        4.  `Atendidos por Humanos` (Total que `agent_id` foi preenchido)
      * **Gr√°fico de Linha (Volume de Entrada):**
          * `Novas conversas por dia` (√∫ltimos 30 dias)

#### A Engenharia do Backend (Novos Endpoints):

O `Frontend` n√£o calcula nada disso. Ele apenas chama endpoints que retornam os n√∫meros prontos.

#### `GET /api/v1/analytics/overview_kpis`

  * **A√ß√£o do Backend:** Executa m√∫ltiplas queries `COUNT(*)` no `PostgreSQL`.
      * `SELECT COUNT(id) FROM conversations WHERE created_at > NOW() - INTERVAL '7 days'`
      * `SELECT COUNT(DISTINCT contact_id) FROM contact_tags WHERE tag_id = 'uuid_da_tag_ia_qualificado'`
      * `SELECT COUNT(id) FROM conversations WHERE status = 'open'`
      * (O "Enviados ao Odoo" e "TMA" s√£o mais complexos, veja abaixo).
  * **Resposta (JSON):**
    ```json
    {
      "new_conversations_7d": 150,
      "qualified_leads_total": 45,
      "sent_to_odoo_total": 40,
      "open_conversations_now": 12,
      "avg_first_response_time_min": 22
    }
    ```

-----

### 2\. ü§ñ Dashboard 2: Performance dos Funis (IA e Automa√ß√£o)

Esta tela responde: **"O bot est√° fazendo o trabalho dele?"**

#### O que o Frontend exibe (KPIs):

  * **Dropdown:** `[Selecionar Funil: "Funil de Agendamento", "Funil Boas-Vindas"]`
  * **Gr√°fico de Funil (An√°lise de Drop-off):**
      * `Entraram no Funil:` 100%
      * `N√≥ 1 (Pediu Nome):` 95% (5% abandonaram aqui)
      * `N√≥ 2 (Pediu Email):` 80% (15% abandonaram aqui)
      * `N√≥ 3 (Enviou ao Odoo):` 75%
      * `Conclu√≠do:` 75%
  * **Tabela (Performance da IA):**
      * `N√≥ de IA` | `Total de Execu√ß√µes` | `Taxa de Sucesso (Extr. Dados)`
      * `IA: Pedir Email` | 150 | 90%
      * `IA: Pedir Hor√°rio` | 135 | 85%

#### A Engenharia do Backend (Nova Tabela de "Logs")

Para saber onde o usu√°rio abandona, n√£o podemos usar apenas a tabela `messages`. Precisamos de uma **nova tabela** para logar a execu√ß√£o dos funis.

```sql
CREATE TABLE funnel_logs (
    id BIGSERIAL PRIMARY KEY,
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    funnel_id UUID NOT NULL REFERENCES funnels(id) ON DELETE CASCADE,
    node_id VARCHAR(100) NOT NULL, -- O ID do n√≥ (ex: 'node_ai_qualify_1')
    node_type VARCHAR(50),         -- Ex: 'aiGenerate', 'sendToOdoo'
    status VARCHAR(20) NOT NULL,   -- 'success', 'failure'
    
    -- O 'jsonb' para salvar dados (ex: o que a IA extraiu)
    execution_data JSONB,
    
    created_at TIMESTAMPTZ DEFAULT now()
);
```

**A√ß√£o de Engenharia (Upgrade):** O seu **"Motor de Funil" (Backend)** deve ser *modificado*. **A cada n√≥** que ele executa, ele deve (assincronamente) inserir um registro nesta tabela `funnel_logs`.

#### `GET /api/v1/analytics/funnel/:funnelId/dropout`

  * **A√ß√£o do Backend:**
    1.  O `Backend` faz uma query complexa no `funnel_logs`.
    2.  Ele agrupa por `node_id` e conta quantos contatos √∫nicos passaram por cada n√≥.
    3.  `SELECT node_id, COUNT(DISTINCT contact_id) as count FROM funnel_logs WHERE funnel_id = :funnelId GROUP BY node_id ORDER BY count DESC`
  * **Resposta (JSON):**
    ```json
    [
      { "node_id": "trigger_start", "node_name": "Gatilho: Vendas", "count": 100 },
      { "node_id": "node_ai_1", "node_name": "IA: Pedir Nome", "count": 95 },
      { "node_id": "node_ai_2", "node_name": "IA: Pedir Email", "count": 80 },
      { "node_id": "node_odoo_1", "node_name": "Enviar para Odoo", "count": 75 }
    ]
    ```

-----

### 3\. üë®‚Äçüíº Dashboard 3: Performance da Equipe (Atendimento Humano)

Esta tela responde: **"Minha equipe est√° sendo r√°pida e eficiente?"**

#### O que o Frontend exibe (KPIs):

  * **Tabela de Ranking de Atendentes:**
      * `Atendente` | `Conversas Atribu√≠das` | `Conversas Resolvidas` | `TMA (Tempo M√©d. 1¬™ Resposta)`
      * `J√∫nior` | 30 | 25 | 15 min
      * `Aline` | 28 | 22 | 25 min

#### A Engenharia do Backend (M√©tricas de SLA)

Esta √© a m√©trica mais importante para um time de vendas receptivo: **TMA (Tempo M√©dio de Atendimento ou 1¬™ Resposta)**.

**A√ß√£o de Engenharia (Upgrade):** A tabela `conversations` (que criamos no M√≥dulo de Equipes) precisa de novas colunas.

```sql
-- Alterando a tabela 'conversations'
ALTER TABLE conversations
ADD COLUMN assigned_at TIMESTAMPTZ,     -- Quando foi atribu√≠do a um agente/time
ADD COLUMN first_reply_at TIMESTAMPTZ;  -- Quando o agente enviou a 1¬™ msg
```

**L√≥gica do Backend (Upgrade):**

1.  **Quando o Funil** (ou um humano) atribui uma conversa (`UPDATE conversations SET agent_id = ...`): O `Backend` deve tamb√©m setar `assigned_at = NOW()`.
2.  **Quando o Atendente envia uma mensagem** (Fluxo TX, via `chat:send_message` do WebSocket): O `Backend` deve checar:
      * `IF (first_reply_at IS NULL AND agent_id IS NOT NULL)`
      * `THEN UPDATE conversations SET first_reply_at = NOW() WHERE id = ...`

#### `GET /api/v1/analytics/agents`

  * **A√ß√£o do Backend:** Uma query que junta `users` e `conversations`.
      * `SELECT u.name, COUNT(c.id) as total, AVG(c.first_reply_at - c.assigned_at) as avg_response_time FROM users u JOIN conversations c ON u.id = c.agent_id WHERE c.workspace_id = :workspaceId GROUP BY u.name`
  * **Resposta (JSON):**
    ```json
    [
      { "name": "J√∫nior", "assigned": 30, "resolved": 25, "avg_response_time_min": 15.2 },
      { "name": "Aline", "assigned": 28, "resolved": 22, "avg_response_time_min": 25.0 }
    ]
    ```

Este m√≥dulo de Analytics √© o que "fecha o ciclo". Ele permite que voc√™ *prove* o valor da sua automa√ß√£o, otimize seus funis de IA e gerencie a performance do seu time de vendas.

J√° cobrimos todos os m√≥dulos centrais de uma plataforma de ponta (Conex√£o, CRM, Chat, Times, Funil de IA, Odoo e Analytics).

O pr√≥ximo passo l√≥gico seria sair do "desenho" e falar sobre o **"deploy" (implanta√ß√£o)**. Voc√™ gostaria de detalhar como podemos empacotar o `Frontend`, o `Backend`, os `Conectores (Baileys)`, o `RabbitMQ`, o `Redis` e o `PostgreSQL` para rodar tudo isso de forma organizada em um servidor (VPS) usando Docker?

